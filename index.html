<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-font-smoothing: antialiased;
        }

        :root {
            --bg-darkest: #262421;
            --bg-darker: #302e2b;
            --bg-dark: #3d3b38;
            --bg-medium: #4a4847;
            --bg-light: #5d5b59;
            --accent-green: #81b64c;
            --accent-green-hover: #9aca5f;
            --accent-green-dark: #629924;
            --text-white: #ffffff;
            --text-light: #bababa;
            --text-muted: #888888;
            --light-square: #ebecd0;
            --dark-square: #779556;
            --highlight-yellow: rgba(255, 255, 0, 0.4);
            --highlight-move: rgba(255, 255, 0, 0.5);
            --check-red: radial-gradient(ellipse at center, rgba(255,0,0,0.8) 0%, rgba(255,0,0,0.4) 40%, rgba(255,0,0,0) 70%);
            --brilliant: #1baca6;
            --great: #5c8bb0;
            --best: #98bc4b;
            --excellent: #96bc4b;
            --good: #96af8b;
            --book: #a88865;
            --inaccuracy: #f7c631;
            --mistake: #e69d00;
            --miss: #df5f5b;
            --blunder: #ca3431;
        }

        body {
            font-family: 'Montserrat', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg-darkest);
            min-height: 100vh;
            color: var(--text-white);
            overflow-x: hidden;
        }

        /* Header */
        .header {
            background: linear-gradient(180deg, #302e2b 0%, #272522 100%);
            padding: 12px 24px;
            display: flex;
            align-items: center;
            gap: 24px;
            border-bottom: 1px solid rgba(255,255,255,0.08);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 22px;
            font-weight: 700;
            color: var(--text-white);
            text-decoration: none;
            letter-spacing: -0.5px;
        }

        .logo-icon {
            width: 36px;
            height: 36px;
            background: var(--accent-green);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .nav-tabs {
            display: flex;
            gap: 4px;
            background: var(--bg-dark);
            padding: 4px;
            border-radius: 8px;
        }

        .nav-btn {
            background: transparent;
            border: none;
            color: var(--text-light);
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            font-family: inherit;
            transition: all 0.2s ease;
            letter-spacing: 0.3px;
        }

        .nav-btn:hover {
            background: var(--bg-medium);
            color: var(--text-white);
        }

        .nav-btn.active {
            background: var(--accent-green);
            color: var(--text-white);
            box-shadow: 0 2px 8px rgba(129, 182, 76, 0.4);
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-left: auto;
        }

        .difficulty-select {
            background: var(--bg-dark);
            border: 1px solid var(--bg-medium);
            color: var(--text-white);
            padding: 10px 16px;
            border-radius: 6px;
            font-size: 13px;
            font-family: inherit;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%23bababa' viewBox='0 0 16 16'%3E%3Cpath d='M8 11L3 6h10l-5 5z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            padding-right: 36px;
        }

        .difficulty-select:hover {
            border-color: var(--accent-green);
        }

        .difficulty-select:focus {
            outline: none;
            border-color: var(--accent-green);
            box-shadow: 0 0 0 3px rgba(129, 182, 76, 0.2);
        }

        /* Main Layout */
        .main-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 30px;
            gap: 24px;
            max-width: 1400px;
            margin: 0 auto;
        }

        /* Board Container */
        .board-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .board-wrapper {
            display: flex;
            gap: 8px;
            position: relative;
        }

        .board-container {
            position: relative;
            border-radius: 4px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5), 0 2px 8px rgba(0,0,0,0.3);
        }

        .board {
            width: 640px;
            height: 640px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            position: relative;
        }

        .square {
            width: 80px;
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
            transition: background 0.1s ease;
        }

        .square.light {
            background: var(--light-square);
        }

        .square.dark {
            background: var(--dark-square);
        }

        .square.selected {
            background: var(--highlight-yellow) !important;
        }

        .square.last-move {
            background: var(--highlight-move) !important;
        }

        .square.legal-move::after {
            content: '';
            width: 28px;
            height: 28px;
            background: rgba(0, 0, 0, 0.15);
            border-radius: 50%;
            position: absolute;
            pointer-events: none;
            transition: transform 0.15s ease;
        }

        .square.legal-move:hover::after {
            transform: scale(1.15);
        }

        .square.legal-capture::after {
            content: '';
            width: 100%;
            height: 100%;
            border: 6px solid rgba(0, 0, 0, 0.15);
            border-radius: 50%;
            position: absolute;
            box-sizing: border-box;
            pointer-events: none;
        }

        .square.check {
            background: var(--check-red) !important;
        }

        .square.premove {
            background: rgba(255, 150, 0, 0.5) !important;
        }

        /* Pieces */
        .piece {
            width: 90%;
            height: 90%;
            cursor: grab;
            z-index: 10;
            transition: transform 0.08s ease;
            user-select: none;
            -webkit-user-drag: none;
            filter: drop-shadow(2px 4px 3px rgba(0,0,0,0.4));
        }

        .piece:hover {
            transform: scale(1.02);
        }

        .piece.dragging {
            cursor: grabbing;
            transform: scale(1.15);
            z-index: 1000;
            filter: drop-shadow(4px 8px 8px rgba(0,0,0,0.5));
        }

        .ghost-piece {
            position: fixed;
            pointer-events: none;
            z-index: 10000;
            width: 90px;
            height: 90px;
            filter: drop-shadow(4px 8px 8px rgba(0,0,0,0.5));
            transform: translate(-50%, -50%);
        }

        /* Coordinates */
        .coordinate {
            position: absolute;
            font-size: 11px;
            font-weight: 700;
            pointer-events: none;
            user-select: none;
        }

        .coordinate.file {
            bottom: 3px;
            right: 5px;
        }

        .coordinate.rank {
            top: 3px;
            left: 5px;
        }

        .square.light .coordinate {
            color: var(--dark-square);
        }

        .square.dark .coordinate {
            color: var(--light-square);
        }

        /* Eval Bar */
        .eval-bar-container {
            width: 28px;
            height: 640px;
            background: #ffffff;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .eval-bar {
            width: 100%;
            background: #262421;
            position: absolute;
            bottom: 0;
            transition: height 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .eval-text {
            position: absolute;
            width: 100%;
            text-align: center;
            font-size: 10px;
            font-weight: 700;
            padding: 4px 0;
            transition: opacity 0.2s ease;
        }

        .eval-text.white {
            bottom: 0;
            color: #262421;
            background: #ffffff;
        }

        .eval-text.black {
            top: 0;
            color: #ffffff;
            background: #262421;
        }

        /* Captured Pieces */
        .captured-pieces {
            height: 28px;
            display: flex;
            align-items: center;
            gap: 2px;
            padding: 0 8px;
        }

        .captured-piece {
            width: 20px;
            height: 20px;
            opacity: 0.8;
        }

        .material-advantage {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-light);
            margin-left: 8px;
        }

        /* Side Panel */
        .side-panel {
            background: var(--bg-darker);
            border-radius: 8px;
            width: 380px;
            overflow: hidden;
            box-shadow: 0 4px 16px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
        }

        .panel-section {
            border-bottom: 1px solid rgba(255,255,255,0.06);
        }

        /* Player Info */
        .player-info {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 14px 18px;
            background: var(--bg-dark);
            transition: background 0.2s ease;
        }

        .player-info.active {
            background: linear-gradient(90deg, var(--accent-green-dark) 0%, var(--bg-dark) 100%);
        }

        .player-avatar {
            width: 44px;
            height: 44px;
            background: var(--bg-medium);
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 22px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }

        .player-details {
            flex: 1;
        }

        .player-name {
            font-weight: 600;
            font-size: 15px;
            letter-spacing: -0.2px;
        }

        .player-rating {
            color: var(--text-muted);
            font-size: 12px;
            margin-top: 2px;
        }

        .player-clock {
            background: var(--bg-darkest);
            padding: 8px 14px;
            border-radius: 6px;
            font-size: 20px;
            font-weight: 700;
            font-variant-numeric: tabular-nums;
            letter-spacing: 1px;
        }

        .player-clock.active {
            background: var(--accent-green);
            color: var(--text-white);
        }

        /* Tabs */
        .tab-container {
            display: flex;
            background: var(--bg-darkest);
            padding: 4px;
        }

        .tab {
            flex: 1;
            padding: 12px 16px;
            text-align: center;
            cursor: pointer;
            background: transparent;
            border: none;
            color: var(--text-muted);
            font-size: 13px;
            font-weight: 600;
            font-family: inherit;
            transition: all 0.2s ease;
            border-radius: 4px;
            position: relative;
        }

        .tab:hover {
            color: var(--text-light);
        }

        .tab.active {
            color: var(--text-white);
            background: var(--bg-dark);
        }

        /* Moves Container */
        .moves-section {
            flex: 1;
            min-height: 280px;
            max-height: 350px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .moves-container {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }

        .moves-container::-webkit-scrollbar {
            width: 8px;
        }

        .moves-container::-webkit-scrollbar-track {
            background: var(--bg-darkest);
            border-radius: 4px;
        }

        .moves-container::-webkit-scrollbar-thumb {
            background: var(--bg-medium);
            border-radius: 4px;
        }

        .moves-container::-webkit-scrollbar-thumb:hover {
            background: var(--bg-light);
        }

        .move-row {
            display: flex;
            align-items: center;
            padding: 2px 0;
            border-radius: 4px;
        }

        .move-number {
            width: 36px;
            color: var(--text-muted);
            font-size: 12px;
            font-weight: 600;
            text-align: center;
            flex-shrink: 0;
        }

        .move {
            flex: 1;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .move:hover {
            background: var(--bg-dark);
        }

        .move.current {
            background: var(--bg-medium);
        }

        .move-icon {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 700;
            flex-shrink: 0;
        }

        .move.brilliant-move .move-icon { background: var(--brilliant); }
        .move.great-move .move-icon { background: var(--great); }
        .move.best-move .move-icon { background: var(--best); }
        .move.excellent-move .move-icon { background: var(--excellent); }
        .move.good-move .move-icon { background: var(--good); }
        .move.book-move .move-icon { background: var(--book); }
        .move.inaccuracy-move .move-icon { background: var(--inaccuracy); color: #000; }
        .move.mistake-move .move-icon { background: var(--mistake); }
        .move.miss-move .move-icon { background: var(--miss); }
        .move.blunder-move .move-icon { background: var(--blunder); }

        /* Game Status */
        .game-status {
            text-align: center;
            padding: 16px;
            font-size: 15px;
            font-weight: 600;
            color: var(--accent-green);
            background: var(--bg-darkest);
        }

        /* Thinking Indicator */
        .thinking {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 12px 18px;
            color: var(--text-muted);
            background: var(--bg-darkest);
            font-size: 13px;
        }

        .thinking-dots {
            display: flex;
            gap: 4px;
        }

        .thinking-dots span {
            width: 8px;
            height: 8px;
            background: var(--accent-green);
            border-radius: 50%;
            animation: thinking 1.2s infinite;
        }

        .thinking-dots span:nth-child(2) { animation-delay: 0.15s; }
        .thinking-dots span:nth-child(3) { animation-delay: 0.3s; }

        @keyframes thinking {
            0%, 60%, 100% { transform: scale(0.6); opacity: 0.4; }
            30% { transform: scale(1); opacity: 1; }
        }

        /* Game Controls */
        .game-controls {
            display: flex;
            gap: 8px;
            padding: 14px 18px;
            justify-content: center;
            background: var(--bg-darkest);
            border-top: 1px solid rgba(255,255,255,0.06);
        }

        .control-btn {
            background: var(--bg-dark);
            border: none;
            color: var(--text-light);
            width: 44px;
            height: 44px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.15s ease;
        }

        .control-btn:hover {
            background: var(--bg-medium);
            color: var(--text-white);
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        .control-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .control-btn svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }

        /* Action Buttons */
        .action-buttons {
            padding: 14px 18px;
            display: flex;
            gap: 10px;
        }

        .new-game-btn {
            flex: 1;
            background: var(--accent-green);
            border: none;
            color: var(--text-white);
            padding: 14px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 15px;
            font-weight: 700;
            font-family: inherit;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(129, 182, 76, 0.3);
            letter-spacing: 0.3px;
        }

        .new-game-btn:hover {
            background: var(--accent-green-hover);
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(129, 182, 76, 0.4);
        }

        .new-game-btn:active {
            transform: translateY(0);
        }

        .resign-btn {
            background: var(--bg-dark);
            border: 1px solid var(--bg-medium);
            color: var(--text-light);
            padding: 14px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            font-family: inherit;
            transition: all 0.2s ease;
        }

        .resign-btn:hover {
            background: var(--blunder);
            border-color: var(--blunder);
            color: var(--text-white);
        }

        /* Review Panel */
        .review-panel {
            display: none;
        }

        .review-panel.active {
            display: block;
        }

        .accuracy-section {
            padding: 24px;
            background: var(--bg-darkest);
        }

        .accuracy-row {
            display: flex;
            justify-content: center;
            gap: 40px;
        }

        .accuracy-item {
            text-align: center;
        }

        .accuracy-ring {
            width: 110px;
            height: 110px;
            border-radius: 50%;
            position: relative;
            margin: 0 auto 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .accuracy-ring svg {
            position: absolute;
            width: 100%;
            height: 100%;
            transform: rotate(-90deg);
        }

        .accuracy-ring circle {
            fill: none;
            stroke-width: 8;
        }

        .accuracy-ring .bg {
            stroke: var(--bg-dark);
        }

        .accuracy-ring .progress {
            stroke-linecap: round;
            transition: stroke-dashoffset 1s ease;
        }

        .accuracy-ring.white .progress {
            stroke: var(--text-white);
        }

        .accuracy-ring.black .progress {
            stroke: var(--text-muted);
        }

        .accuracy-value {
            font-size: 28px;
            font-weight: 700;
            letter-spacing: -1px;
        }

        .accuracy-label {
            font-size: 12px;
            color: var(--text-muted);
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Classification Stats */
        .classification-section {
            padding: 0 18px 18px;
        }

        .classification-header {
            display: flex;
            justify-content: flex-end;
            padding: 10px 0;
            gap: 8px;
            font-size: 11px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .classification-header span {
            width: 40px;
            text-align: center;
        }

        .classification-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255,255,255,0.04);
        }

        .classification-row:last-child {
            border-bottom: none;
        }

        .classification-label {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .classification-icon {
            width: 26px;
            height: 26px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
            font-weight: 700;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .classification-icon.brilliant { background: var(--brilliant); }
        .classification-icon.great { background: var(--great); }
        .classification-icon.best { background: var(--best); }
        .classification-icon.excellent { background: var(--excellent); }
        .classification-icon.good { background: var(--good); }
        .classification-icon.book { background: var(--book); }
        .classification-icon.inaccuracy { background: var(--inaccuracy); color: #000; }
        .classification-icon.mistake { background: var(--mistake); }
        .classification-icon.miss { background: var(--miss); }
        .classification-icon.blunder { background: var(--blunder); }

        .classification-name {
            font-size: 13px;
            font-weight: 500;
        }

        .classification-counts {
            display: flex;
            gap: 8px;
        }

        .count-badge {
            width: 40px;
            text-align: center;
            font-size: 14px;
            font-weight: 600;
            padding: 4px 0;
            border-radius: 4px;
            background: var(--bg-dark);
        }

        .count-badge.has-value {
            background: var(--bg-medium);
        }

        /* Review Move Info */
        .review-move-info {
            background: var(--bg-dark);
            margin: 16px;
            border-radius: 8px;
            overflow: hidden;
        }

        .review-move-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 14px 16px;
            background: var(--bg-darkest);
        }

        .review-move-class {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .review-move-notation {
            font-size: 16px;
            font-weight: 600;
        }

        .eval-change {
            font-size: 14px;
            font-weight: 600;
            padding: 4px 10px;
            border-radius: 4px;
        }

        .eval-change.positive {
            background: rgba(129, 182, 76, 0.2);
            color: var(--accent-green);
        }

        .eval-change.negative {
            background: rgba(202, 52, 49, 0.2);
            color: var(--blunder);
        }

        .review-best-move {
            padding: 12px 16px;
            font-size: 13px;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .review-best-move strong {
            color: var(--accent-green);
            font-weight: 600;
        }

        /* Arrow Overlay */
        .arrow-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
        }

        /* Modals */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(4px);
            animation: fadeIn 0.2s ease;
        }

        .modal-overlay.active {
            display: flex;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal {
            background: var(--bg-darker);
            padding: 32px 40px;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 24px 80px rgba(0, 0, 0, 0.6);
            animation: modalSlide 0.3s ease;
            max-width: 420px;
        }

        @keyframes modalSlide {
            from { transform: translateY(-20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .modal-icon {
            width: 64px;
            height: 64px;
            background: var(--bg-dark);
            border-radius: 50%;
            margin: 0 auto 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
        }

        .modal-title {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 10px;
            letter-spacing: -0.5px;
        }

        .modal-subtitle {
            color: var(--text-muted);
            font-size: 15px;
            margin-bottom: 28px;
            line-height: 1.5;
        }

        .modal-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .modal-btn {
            padding: 14px 28px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            font-family: inherit;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
        }

        .modal-btn.primary {
            background: var(--accent-green);
            color: var(--text-white);
        }

        .modal-btn.primary:hover {
            background: var(--accent-green-hover);
        }

        .modal-btn.secondary {
            background: var(--bg-dark);
            color: var(--text-light);
        }

        .modal-btn.secondary:hover {
            background: var(--bg-medium);
            color: var(--text-white);
        }

        /* Promotion Modal */
        .promotion-modal .modal {
            padding: 24px;
        }

        .promotion-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 16px;
            color: var(--text-muted);
        }

        .promotion-pieces {
            display: flex;
            gap: 8px;
        }

        .promotion-piece {
            width: 80px;
            height: 80px;
            background: var(--bg-dark);
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.15s ease;
            border: 2px solid transparent;
        }

        .promotion-piece:hover {
            background: var(--bg-medium);
            border-color: var(--accent-green);
            transform: scale(1.05);
        }

        .promotion-piece img {
            width: 65px;
            height: 65px;
            filter: drop-shadow(2px 3px 3px rgba(0,0,0,0.3));
        }

        /* Analyzing Spinner */
        .analyzing-container {
            padding: 60px 40px;
            text-align: center;
        }

        .spinner {
            width: 48px;
            height: 48px;
            border: 4px solid var(--bg-dark);
            border-top: 4px solid var(--accent-green);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .analyzing-text {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-white);
            margin-bottom: 8px;
        }

        .analyzing-subtext {
            font-size: 13px;
            color: var(--text-muted);
        }

        /* Empty State */
        .empty-state {
            padding: 40px;
            text-align: center;
            color: var(--text-muted);
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        .empty-state-text {
            font-size: 14px;
            line-height: 1.6;
        }

        /* Responsive */
        @media (max-width: 1100px) {
            .main-container {
                flex-direction: column;
                align-items: center;
                padding: 20px;
            }

            .board {
                width: 560px;
                height: 560px;
            }

            .square {
                width: 70px;
                height: 70px;
            }

            .eval-bar-container {
                height: 560px;
            }

            .side-panel {
                width: 100%;
                max-width: 560px;
            }
        }
    </style>
</head>
<body>
    <header class="header">
        <a href="#" class="logo">
            <div class="logo-icon">â™ž</div>
            <span>Chess</span>
        </a>
        
        <div class="nav-tabs">
            <button class="nav-btn active" id="playTab" onclick="showGame()">Play</button>
            <button class="nav-btn" id="reviewTab" onclick="startReview()">Game Review</button>
        </div>

        <div class="header-controls">
            <select class="difficulty-select" id="difficulty">
                <option value="1">Beginner</option>
                <option value="2">Intermediate</option>
                <option value="3" selected>Advanced</option>
                <option value="4">Expert</option>
            </select>
        </div>
    </header>

    <main class="main-container">
        <section class="board-section">
            <div class="captured-pieces" id="capturedBlack"></div>
            
            <div class="board-wrapper">
                <div class="eval-bar-container">
                    <div class="eval-bar" id="evalBar" style="height: 50%;"></div>
                    <div class="eval-text white" id="evalTextWhite">0.0</div>
                    <div class="eval-text black" id="evalTextBlack"></div>
                </div>
                
                <div class="board-container">
                    <div class="board" id="board"></div>
                    <svg class="arrow-overlay" id="arrowOverlay"></svg>
                </div>
            </div>
            
            <div class="captured-pieces" id="capturedWhite"></div>
        </section>

        <aside class="side-panel">
            <div class="player-info panel-section" id="blackPlayer">
                <div class="player-avatar">ðŸ¤–</div>
                <div class="player-details">
                    <div class="player-name">Stockfish AI</div>
                    <div class="player-rating">Level <span id="botLevel">3</span> â€¢ Black</div>
                </div>
                <div class="player-clock" id="blackClock">10:00</div>
            </div>

            <div class="thinking" id="thinkingIndicator" style="display: none;">
                <span>Thinking</span>
                <div class="thinking-dots">
                    <span></span><span></span><span></span>
                </div>
            </div>

            <div class="tab-container panel-section">
                <button class="tab active" onclick="showPanelTab('moves')">Moves</button>
                <button class="tab" onclick="showPanelTab('review')">Analysis</button>
            </div>

            <div id="movesPanel" class="moves-section">
                <div class="moves-container" id="movesContainer">
                    <div class="empty-state">
                        <div class="empty-state-icon">â™Ÿ</div>
                        <div class="empty-state-text">No moves yet.<br>Make your first move!</div>
                    </div>
                </div>
            </div>

            <div id="reviewPanel" class="review-panel">
                <div id="reviewContent">
                    <div class="empty-state">
                        <div class="empty-state-icon">ðŸ“Š</div>
                        <div class="empty-state-text">Play a game first, then click<br>"Game Review" to analyze your moves.</div>
                    </div>
                </div>
            </div>

            <div class="game-status" id="gameStatus"></div>

            <div class="game-controls panel-section">
                <button class="control-btn" onclick="goToStart()" title="Go to start">
                    <svg viewBox="0 0 24 24"><path d="M18.41 16.59L13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z"/></svg>
                </button>
                <button class="control-btn" onclick="goBack()" title="Previous move">
                    <svg viewBox="0 0 24 24"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/></svg>
                </button>
                <button class="control-btn" onclick="goForward()" title="Next move">
                    <svg viewBox="0 0 24 24"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/></svg>
                </button>
                <button class="control-btn" onclick="goToEnd()" title="Go to end">
                    <svg viewBox="0 0 24 24"><path d="M5.59 7.41L10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z"/></svg>
                </button>
            </div>

            <div class="player-info panel-section" id="whitePlayer">
                <div class="player-avatar">ðŸ‘¤</div>
                <div class="player-details">
                    <div class="player-name">You</div>
                    <div class="player-rating">Playing as White</div>
                </div>
                <div class="player-clock active" id="whiteClock">10:00</div>
            </div>

            <div class="action-buttons">
                <button class="new-game-btn" onclick="newGame()">New Game</button>
                <button class="resign-btn" onclick="resign()">Resign</button>
            </div>
        </aside>
    </main>

    <!-- Game Over Modal -->
    <div class="modal-overlay" id="gameOverModal">
        <div class="modal">
            <div class="modal-icon" id="gameOverIcon">ðŸ‘‘</div>
            <h2 class="modal-title" id="gameOverTitle">Game Over</h2>
            <p class="modal-subtitle" id="gameOverMessage">You won by checkmate!</p>
            <div class="modal-buttons">
                <button class="modal-btn primary" onclick="newGame()">Play Again</button>
                <button class="modal-btn secondary" onclick="closeModal(); startReview();">Review Game</button>
            </div>
        </div>
    </div>

    <!-- Promotion Modal -->
    <div class="modal-overlay promotion-modal" id="promotionModal">
        <div class="modal">
            <div class="promotion-title">Choose promotion piece</div>
            <div class="promotion-pieces" id="promotionPieces"></div>
        </div>
    </div>

    <script>
        // Piece images
        const PIECE_IMAGES = {
            'K': 'https://raw.githubusercontent.com/corrodedfridge-tech/chess/main/whiteking.png',
            'Q': 'https://raw.githubusercontent.com/corrodedfridge-tech/chess/main/whitequeen.png',
            'R': 'https://raw.githubusercontent.com/corrodedfridge-tech/chess/main/whiterook.png',
            'B': 'https://raw.githubusercontent.com/corrodedfridge-tech/chess/main/whitebishop.png',
            'N': 'https://raw.githubusercontent.com/corrodedfridge-tech/chess/main/whiteknight.png',
            'P': 'https://raw.githubusercontent.com/corrodedfridge-tech/chess/main/whitepawn.png',
            'k': 'https://raw.githubusercontent.com/corrodedfridge-tech/chess/main/blackking.png',
            'q': 'https://raw.githubusercontent.com/corrodedfridge-tech/chess/main/blackqueen.png',
            'r': 'https://raw.githubusercontent.com/corrodedfridge-tech/chess/main/blackrook.png',
            'b': 'https://raw.githubusercontent.com/corrodedfridge-tech/chess/main/blackbishop.png',
            'n': 'https://raw.githubusercontent.com/corrodedfridge-tech/chess/main/blackknight.png',
            'p': 'https://raw.githubusercontent.com/corrodedfridge-tech/chess/main/blackpawn.png'
        };

        // Chess Engine
        class ChessEngine {
            constructor() {
                this.reset();
            }

            reset() {
                this.board = [
                    ['r','n','b','q','k','b','n','r'],
                    ['p','p','p','p','p','p','p','p'],
                    [null,null,null,null,null,null,null,null],
                    [null,null,null,null,null,null,null,null],
                    [null,null,null,null,null,null,null,null],
                    [null,null,null,null,null,null,null,null],
                    ['P','P','P','P','P','P','P','P'],
                    ['R','N','B','Q','K','B','N','R']
                ];
                this.turn = 'white';
                this.castling = { K: true, Q: true, k: true, q: true };
                this.enPassant = null;
                this.halfMoveClock = 0;
                this.fullMoveNumber = 1;
                this.moveHistory = [];
                this.positionHistory = [];
                this.capturedPieces = { white: [], black: [] };
            }

            clone() {
                const copy = new ChessEngine();
                copy.board = this.board.map(row => [...row]);
                copy.turn = this.turn;
                copy.castling = { ...this.castling };
                copy.enPassant = this.enPassant;
                copy.halfMoveClock = this.halfMoveClock;
                copy.fullMoveNumber = this.fullMoveNumber;
                copy.moveHistory = [...this.moveHistory];
                copy.positionHistory = [...this.positionHistory];
                copy.capturedPieces = {
                    white: [...this.capturedPieces.white],
                    black: [...this.capturedPieces.black]
                };
                return copy;
            }

            isWhite(piece) { return piece && piece === piece.toUpperCase(); }
            isBlack(piece) { return piece && piece === piece.toLowerCase(); }
            getPieceColor(piece) { return piece ? (this.isWhite(piece) ? 'white' : 'black') : null; }

            getKingPosition(color) {
                const king = color === 'white' ? 'K' : 'k';
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (this.board[r][c] === king) return { row: r, col: c };
                    }
                }
                return null;
            }

            isSquareAttacked(row, col, byColor) {
                const pawnDir = byColor === 'white' ? 1 : -1;
                const pawn = byColor === 'white' ? 'P' : 'p';
                if (row + pawnDir >= 0 && row + pawnDir < 8) {
                    if (col - 1 >= 0 && this.board[row + pawnDir][col - 1] === pawn) return true;
                    if (col + 1 < 8 && this.board[row + pawnDir][col + 1] === pawn) return true;
                }

                const knight = byColor === 'white' ? 'N' : 'n';
                const knightMoves = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
                for (const [dr, dc] of knightMoves) {
                    const r = row + dr, c = col + dc;
                    if (r >= 0 && r < 8 && c >= 0 && c < 8 && this.board[r][c] === knight) return true;
                }

                const king = byColor === 'white' ? 'K' : 'k';
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        if (dr === 0 && dc === 0) continue;
                        const r = row + dr, c = col + dc;
                        if (r >= 0 && r < 8 && c >= 0 && c < 8 && this.board[r][c] === king) return true;
                    }
                }

                const directions = [
                    { dr: -1, dc: 0, pieces: byColor === 'white' ? ['R', 'Q'] : ['r', 'q'] },
                    { dr: 1, dc: 0, pieces: byColor === 'white' ? ['R', 'Q'] : ['r', 'q'] },
                    { dr: 0, dc: -1, pieces: byColor === 'white' ? ['R', 'Q'] : ['r', 'q'] },
                    { dr: 0, dc: 1, pieces: byColor === 'white' ? ['R', 'Q'] : ['r', 'q'] },
                    { dr: -1, dc: -1, pieces: byColor === 'white' ? ['B', 'Q'] : ['b', 'q'] },
                    { dr: -1, dc: 1, pieces: byColor === 'white' ? ['B', 'Q'] : ['b', 'q'] },
                    { dr: 1, dc: -1, pieces: byColor === 'white' ? ['B', 'Q'] : ['b', 'q'] },
                    { dr: 1, dc: 1, pieces: byColor === 'white' ? ['B', 'Q'] : ['b', 'q'] }
                ];

                for (const { dr, dc, pieces } of directions) {
                    let r = row + dr, c = col + dc;
                    while (r >= 0 && r < 8 && c >= 0 && c < 8) {
                        if (this.board[r][c]) {
                            if (pieces.includes(this.board[r][c])) return true;
                            break;
                        }
                        r += dr; c += dc;
                    }
                }
                return false;
            }

            isInCheck(color) {
                const kingPos = this.getKingPosition(color);
                return kingPos ? this.isSquareAttacked(kingPos.row, kingPos.col, color === 'white' ? 'black' : 'white') : false;
            }

            generatePseudoLegalMoves(color) {
                const moves = [];

                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = this.board[r][c];
                        if (!piece || this.getPieceColor(piece) !== color) continue;

                        const pieceType = piece.toUpperCase();

                        if (pieceType === 'P') {
                            const dir = color === 'white' ? -1 : 1;
                            const startRow = color === 'white' ? 6 : 1;
                            const promoRow = color === 'white' ? 0 : 7;

                            if (r + dir >= 0 && r + dir < 8 && !this.board[r + dir][c]) {
                                if (r + dir === promoRow) {
                                    ['Q', 'R', 'B', 'N'].forEach(promo => {
                                        moves.push({ from: {row: r, col: c}, to: {row: r + dir, col: c}, promotion: promo });
                                    });
                                } else {
                                    moves.push({ from: {row: r, col: c}, to: {row: r + dir, col: c} });
                                }
                            }

                            if (r === startRow && !this.board[r + dir][c] && !this.board[r + 2*dir][c]) {
                                moves.push({ from: {row: r, col: c}, to: {row: r + 2*dir, col: c} });
                            }

                            for (const dc of [-1, 1]) {
                                const nc = c + dc;
                                if (nc >= 0 && nc < 8 && r + dir >= 0 && r + dir < 8) {
                                    const target = this.board[r + dir][nc];
                                    const isEnPassant = this.enPassant && this.enPassant.row === r + dir && this.enPassant.col === nc;
                                    if ((target && this.getPieceColor(target) !== color) || isEnPassant) {
                                        if (r + dir === promoRow) {
                                            ['Q', 'R', 'B', 'N'].forEach(promo => {
                                                moves.push({ from: {row: r, col: c}, to: {row: r + dir, col: nc}, promotion: promo, isEnPassant });
                                            });
                                        } else {
                                            moves.push({ from: {row: r, col: c}, to: {row: r + dir, col: nc}, isEnPassant });
                                        }
                                    }
                                }
                            }
                        }

                        if (pieceType === 'N') {
                            const knightMoves = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
                            for (const [dr, dc] of knightMoves) {
                                const nr = r + dr, nc = c + dc;
                                if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                                    const target = this.board[nr][nc];
                                    if (!target || this.getPieceColor(target) !== color) {
                                        moves.push({ from: {row: r, col: c}, to: {row: nr, col: nc} });
                                    }
                                }
                            }
                        }

                        if (pieceType === 'B' || pieceType === 'Q') {
                            for (const [dr, dc] of [[-1,-1],[-1,1],[1,-1],[1,1]]) {
                                let nr = r + dr, nc = c + dc;
                                while (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                                    const target = this.board[nr][nc];
                                    if (!target) {
                                        moves.push({ from: {row: r, col: c}, to: {row: nr, col: nc} });
                                    } else {
                                        if (this.getPieceColor(target) !== color) {
                                            moves.push({ from: {row: r, col: c}, to: {row: nr, col: nc} });
                                        }
                                        break;
                                    }
                                    nr += dr; nc += dc;
                                }
                            }
                        }

                        if (pieceType === 'R' || pieceType === 'Q') {
                            for (const [dr, dc] of [[-1,0],[1,0],[0,-1],[0,1]]) {
                                let nr = r + dr, nc = c + dc;
                                while (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                                    const target = this.board[nr][nc];
                                    if (!target) {
                                        moves.push({ from: {row: r, col: c}, to: {row: nr, col: nc} });
                                    } else {
                                        if (this.getPieceColor(target) !== color) {
                                            moves.push({ from: {row: r, col: c}, to: {row: nr, col: nc} });
                                        }
                                        break;
                                    }
                                    nr += dr; nc += dc;
                                }
                            }
                        }

                        if (pieceType === 'K') {
                            for (let dr = -1; dr <= 1; dr++) {
                                for (let dc = -1; dc <= 1; dc++) {
                                    if (dr === 0 && dc === 0) continue;
                                    const nr = r + dr, nc = c + dc;
                                    if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                                        const target = this.board[nr][nc];
                                        if (!target || this.getPieceColor(target) !== color) {
                                            moves.push({ from: {row: r, col: c}, to: {row: nr, col: nc} });
                                        }
                                    }
                                }
                            }

                            const row = color === 'white' ? 7 : 0;
                            if (r === row && c === 4) {
                                const kingSide = color === 'white' ? 'K' : 'k';
                                const queenSide = color === 'white' ? 'Q' : 'q';

                                if (this.castling[kingSide] && !this.board[row][5] && !this.board[row][6] &&
                                    !this.isInCheck(color) &&
                                    !this.isSquareAttacked(row, 5, color === 'white' ? 'black' : 'white') &&
                                    !this.isSquareAttacked(row, 6, color === 'white' ? 'black' : 'white')) {
                                    moves.push({ from: {row: r, col: c}, to: {row: row, col: 6}, isCastling: 'kingside' });
                                }

                                if (this.castling[queenSide] && !this.board[row][3] && !this.board[row][2] && !this.board[row][1] &&
                                    !this.isInCheck(color) &&
                                    !this.isSquareAttacked(row, 3, color === 'white' ? 'black' : 'white') &&
                                    !this.isSquareAttacked(row, 2, color === 'white' ? 'black' : 'white')) {
                                    moves.push({ from: {row: r, col: c}, to: {row: row, col: 2}, isCastling: 'queenside' });
                                }
                            }
                        }
                    }
                }
                return moves;
            }

            generateLegalMoves(color = this.turn) {
                const pseudoMoves = this.generatePseudoLegalMoves(color);
                return pseudoMoves.filter(move => {
                    const copy = this.clone();
                    copy.makeMove(move, true);
                    return !copy.isInCheck(color);
                });
            }

            makeMove(move, skipValidation = false) {
                const { from, to, promotion, isEnPassant, isCastling } = move;
                const piece = this.board[from.row][from.col];
                const captured = this.board[to.row][to.col];
                const color = this.getPieceColor(piece);

                if (!skipValidation) {
                    this.positionHistory.push(this.getBoardState());
                }

                if (captured) {
                    this.capturedPieces[color].push(captured);
                }

                if (isEnPassant) {
                    const capturedRow = color === 'white' ? to.row + 1 : to.row - 1;
                    this.capturedPieces[color].push(this.board[capturedRow][to.col]);
                    this.board[capturedRow][to.col] = null;
                }

                this.board[to.row][to.col] = promotion ? (color === 'white' ? promotion : promotion.toLowerCase()) : piece;
                this.board[from.row][from.col] = null;

                if (isCastling) {
                    const row = from.row;
                    if (isCastling === 'kingside') {
                        this.board[row][5] = this.board[row][7];
                        this.board[row][7] = null;
                    } else {
                        this.board[row][3] = this.board[row][0];
                        this.board[row][0] = null;
                    }
                }

                if (piece.toUpperCase() === 'K') {
                    if (color === 'white') { this.castling.K = false; this.castling.Q = false; }
                    else { this.castling.k = false; this.castling.q = false; }
                }
                if (piece.toUpperCase() === 'R') {
                    if (from.row === 7 && from.col === 7) this.castling.K = false;
                    if (from.row === 7 && from.col === 0) this.castling.Q = false;
                    if (from.row === 0 && from.col === 7) this.castling.k = false;
                    if (from.row === 0 && from.col === 0) this.castling.q = false;
                }

                if (piece.toUpperCase() === 'P' && Math.abs(to.row - from.row) === 2) {
                    this.enPassant = { row: (from.row + to.row) / 2, col: from.col };
                } else {
                    this.enPassant = null;
                }

                if (captured || piece.toUpperCase() === 'P') this.halfMoveClock = 0;
                else this.halfMoveClock++;

                if (color === 'black') this.fullMoveNumber++;

                if (!skipValidation) {
                    const notation = this.getMoveNotation(move, piece, captured, isCastling);
                    this.moveHistory.push({
                        ...move,
                        notation,
                        piece,
                        captured,
                        boardState: this.getBoardState()
                    });
                }

                this.turn = this.turn === 'white' ? 'black' : 'white';
                return { captured, isEnPassant, isCastling };
            }

            getMoveNotation(move, piece, captured, isCastling) {
                if (isCastling === 'kingside') return 'O-O';
                if (isCastling === 'queenside') return 'O-O-O';

                const files = 'abcdefgh';
                const pieceType = piece.toUpperCase();
                let notation = '';

                if (pieceType !== 'P') notation += pieceType;
                if (captured || move.isEnPassant) {
                    if (pieceType === 'P') notation += files[move.from.col];
                    notation += 'x';
                }
                notation += files[move.to.col] + (8 - move.to.row);
                if (move.promotion) notation += '=' + move.promotion;

                const copy = this.clone();
                const oppColor = this.getPieceColor(piece) === 'white' ? 'black' : 'white';
                if (copy.isInCheck(oppColor)) {
                    notation += copy.generateLegalMoves(oppColor).length === 0 ? '#' : '+';
                }
                return notation;
            }

            getBoardState() {
                return {
                    board: this.board.map(row => [...row]),
                    turn: this.turn,
                    castling: { ...this.castling },
                    enPassant: this.enPassant ? { ...this.enPassant } : null
                };
            }

            loadBoardState(state) {
                this.board = state.board.map(row => [...row]);
                this.turn = state.turn;
                this.castling = { ...state.castling };
                this.enPassant = state.enPassant ? { ...state.enPassant } : null;
            }

            isCheckmate() { return this.isInCheck(this.turn) && this.generateLegalMoves().length === 0; }
            isStalemate() { return !this.isInCheck(this.turn) && this.generateLegalMoves().length === 0; }

            isDraw() {
                if (this.isStalemate()) return 'stalemate';
                if (this.halfMoveClock >= 100) return 'fifty-move';
                if (this.isInsufficientMaterial()) return 'insufficient';
                return false;
            }

            isInsufficientMaterial() {
                const pieces = [];
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (this.board[r][c]) pieces.push({ piece: this.board[r][c], row: r, col: c });
                    }
                }
                if (pieces.length === 2) return true;
                if (pieces.length === 3) {
                    const nonKing = pieces.find(p => p.piece.toUpperCase() !== 'K');
                    if (nonKing && ['N', 'B'].includes(nonKing.piece.toUpperCase())) return true;
                }
                return false;
            }

            evaluate() {
                const pieceValues = { P: 100, N: 320, B: 330, R: 500, Q: 900, K: 20000 };
                
                const tables = {
                    P: [[0,0,0,0,0,0,0,0],[50,50,50,50,50,50,50,50],[10,10,20,30,30,20,10,10],[5,5,10,25,25,10,5,5],[0,0,0,20,20,0,0,0],[5,-5,-10,0,0,-10,-5,5],[5,10,10,-20,-20,10,10,5],[0,0,0,0,0,0,0,0]],
                    N: [[-50,-40,-30,-30,-30,-30,-40,-50],[-40,-20,0,0,0,0,-20,-40],[-30,0,10,15,15,10,0,-30],[-30,5,15,20,20,15,5,-30],[-30,0,15,20,20,15,0,-30],[-30,5,10,15,15,10,5,-30],[-40,-20,0,5,5,0,-20,-40],[-50,-40,-30,-30,-30,-30,-40,-50]],
                    B: [[-20,-10,-10,-10,-10,-10,-10,-20],[-10,0,0,0,0,0,0,-10],[-10,0,5,10,10,5,0,-10],[-10,5,5,10,10,5,5,-10],[-10,0,10,10,10,10,0,-10],[-10,10,10,10,10,10,10,-10],[-10,5,0,0,0,0,5,-10],[-20,-10,-10,-10,-10,-10,-10,-20]],
                    R: [[0,0,0,0,0,0,0,0],[5,10,10,10,10,10,10,5],[-5,0,0,0,0,0,0,-5],[-5,0,0,0,0,0,0,-5],[-5,0,0,0,0,0,0,-5],[-5,0,0,0,0,0,0,-5],[-5,0,0,0,0,0,0,-5],[0,0,0,5,5,0,0,0]],
                    Q: [[-20,-10,-10,-5,-5,-10,-10,-20],[-10,0,0,0,0,0,0,-10],[-10,0,5,5,5,5,0,-10],[-5,0,5,5,5,5,0,-5],[0,0,5,5,5,5,0,-5],[-10,5,5,5,5,5,0,-10],[-10,0,5,0,0,0,0,-10],[-20,-10,-10,-5,-5,-10,-10,-20]],
                    K: [[-30,-40,-40,-50,-50,-40,-40,-30],[-30,-40,-40,-50,-50,-40,-40,-30],[-30,-40,-40,-50,-50,-40,-40,-30],[-30,-40,-40,-50,-50,-40,-40,-30],[-20,-30,-30,-40,-40,-30,-30,-20],[-10,-20,-20,-20,-20,-20,-20,-10],[20,20,0,0,0,0,20,20],[20,30,10,0,0,10,30,20]]
                };

                let score = 0;
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = this.board[r][c];
                        if (!piece) continue;
                        const isWhite = this.isWhite(piece);
                        const pieceType = piece.toUpperCase();
                        const value = pieceValues[pieceType] || 0;
                        const table = tables[pieceType];
                        const tableValue = table ? (isWhite ? table[r][c] : table[7-r][c]) : 0;
                        score += isWhite ? (value + tableValue) : -(value + tableValue);
                    }
                }
                return score;
            }
        }

        // AI
        class ChessAI {
            constructor(depth = 3) {
                this.depth = depth;
            }

            getBestMove(engine) {
                const moves = engine.generateLegalMoves();
                if (moves.length === 0) return null;

                let bestMove = null;
                let bestScore = engine.turn === 'white' ? -Infinity : Infinity;

                moves.sort((a, b) => this.getMoveScore(engine, b) - this.getMoveScore(engine, a));

                for (const move of moves) {
                    const copy = engine.clone();
                    copy.makeMove(move, true);
                    const score = this.minimax(copy, this.depth - 1, -Infinity, Infinity, engine.turn !== 'white');
                    
                    if (engine.turn === 'white' ? score > bestScore : score < bestScore) {
                        bestScore = score;
                        bestMove = move;
                    }
                }
                return { move: bestMove, score: bestScore };
            }

            getMoveScore(engine, move) {
                let score = 0;
                const captured = engine.board[move.to.row][move.to.col];
                if (captured) {
                    const values = { P: 1, N: 3, B: 3, R: 5, Q: 9, K: 0 };
                    score += values[captured.toUpperCase()] * 10;
                }
                if (move.promotion) score += 8;
                if (move.isCastling) score += 2;
                return score;
            }

            minimax(engine, depth, alpha, beta, maximizing) {
                if (depth === 0) return this.quiescence(engine, alpha, beta, maximizing);

                const moves = engine.generateLegalMoves();
                if (moves.length === 0) {
                    if (engine.isInCheck(engine.turn)) return maximizing ? -100000 + (this.depth - depth) : 100000 - (this.depth - depth);
                    return 0;
                }

                moves.sort((a, b) => this.getMoveScore(engine, b) - this.getMoveScore(engine, a));

                if (maximizing) {
                    let maxScore = -Infinity;
                    for (const move of moves) {
                        const copy = engine.clone();
                        copy.makeMove(move, true);
                        const score = this.minimax(copy, depth - 1, alpha, beta, false);
                        maxScore = Math.max(maxScore, score);
                        alpha = Math.max(alpha, score);
                        if (beta <= alpha) break;
                    }
                    return maxScore;
                } else {
                    let minScore = Infinity;
                    for (const move of moves) {
                        const copy = engine.clone();
                        copy.makeMove(move, true);
                        const score = this.minimax(copy, depth - 1, alpha, beta, true);
                        minScore = Math.min(minScore, score);
                        beta = Math.min(beta, score);
                        if (beta <= alpha) break;
                    }
                    return minScore;
                }
            }

            quiescence(engine, alpha, beta, maximizing) {
                const standPat = engine.evaluate();
                if (maximizing) {
                    if (standPat >= beta) return beta;
                    if (alpha < standPat) alpha = standPat;
                } else {
                    if (standPat <= alpha) return alpha;
                    if (beta > standPat) beta = standPat;
                }

                const moves = engine.generateLegalMoves().filter(m => engine.board[m.to.row][m.to.col] !== null);
                for (const move of moves) {
                    const copy = engine.clone();
                    copy.makeMove(move, true);
                    const score = this.quiescence(copy, alpha, beta, !maximizing);
                    if (maximizing) {
                        if (score >= beta) return beta;
                        if (score > alpha) alpha = score;
                    } else {
                        if (score <= alpha) return alpha;
                        if (score < beta) beta = score;
                    }
                }
                return maximizing ? alpha : beta;
            }

            analyzeMove(engineBefore, move, color) {
                const before = engineBefore.clone();
                const after = engineBefore.clone();
                after.makeMove(move, true);

                this.depth = 4;
                const bestResult = this.getBestMove(before);
                const bestMove = bestResult?.move;
                
                if (!bestMove) return { classification: 'book', evalChange: 0 };

                const afterBest = before.clone();
                afterBest.makeMove(bestMove, true);
                const evalAfterBest = afterBest.evaluate() * (color === 'white' ? 1 : -1);
                const evalAfterActual = after.evaluate() * (color === 'white' ? 1 : -1);
                const evalChange = (evalAfterActual - evalAfterBest) / 100;

                const isBestMove = move.from.row === bestMove.from.row && move.from.col === bestMove.from.col &&
                                   move.to.row === bestMove.to.row && move.to.col === bestMove.to.col;

                const isSacrifice = this.isSacrifice(engineBefore, move, color);

                let classification;
                if (isBestMove) classification = 'best';
                else if (evalChange >= -0.05) classification = 'excellent';
                else if (evalChange >= -0.15) classification = 'good';
                else if (evalChange >= -0.5) classification = 'inaccuracy';
                else if (evalChange >= -1.5) classification = 'mistake';
                else classification = 'blunder';

                if (isSacrifice && !isBestMove && evalChange >= 0.5) {
                    const materialLoss = this.getMaterialChange(engineBefore, move, color);
                    if (materialLoss >= 3 && evalChange >= 1.5) classification = 'brilliant';
                }

                if (classification === 'best' && this.isNonObvious(engineBefore, move)) classification = 'great';

                return { classification, evalChange, evalBefore: 0, evalAfter: evalAfterActual / 100, bestMove, isBestMove };
            }

            isSacrifice(engine, move, color) {
                const piece = engine.board[move.from.row][move.from.col];
                const values = { P: 1, N: 3, B: 3, R: 5, Q: 9, K: 0 };
                const pieceValue = values[piece.toUpperCase()];
                const oppColor = color === 'white' ? 'black' : 'white';

                if (engine.isSquareAttacked(move.to.row, move.to.col, oppColor)) {
                    const captured = engine.board[move.to.row][move.to.col];
                    const capturedValue = captured ? values[captured.toUpperCase()] : 0;
                    return pieceValue > capturedValue + 1;
                }
                return false;
            }

            getMaterialChange(engine, move, color) {
                const piece = engine.board[move.from.row][move.from.col];
                const captured = engine.board[move.to.row][move.to.col];
                const values = { P: 1, N: 3, B: 3, R: 5, Q: 9, K: 0 };
                return values[piece.toUpperCase()] - (captured ? values[captured.toUpperCase()] : 0);
            }

            isNonObvious(engine, move) {
                const captured = engine.board[move.to.row][move.to.col];
                return !captured && !move.isCastling;
            }
        }

        // Game State
        let engine = new ChessEngine();
        let ai = new ChessAI(3);
        let selectedSquare = null;
        let legalMoves = [];
        let gameOver = false;
        let reviewMode = false;
        let reviewMoveIndex = -1;
        let moveAnalysis = [];
        let pendingPromotion = null;
        let dragging = false;
        let dragPiece = null;
        let dragStartSquare = null;
        let ghostPiece = null;

        // Initialize
        function init() {
            renderBoard();
            updateMoveList();
            updateEvalBar(0);
            
            document.getElementById('difficulty').addEventListener('change', (e) => {
                ai.depth = parseInt(e.target.value);
                document.getElementById('botLevel').textContent = e.target.value;
            });

            // Keyboard navigation
            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft') goBack();
                if (e.key === 'ArrowRight') goForward();
                if (e.key === 'ArrowUp') { e.preventDefault(); goToStart(); }
                if (e.key === 'ArrowDown') { e.preventDefault(); goToEnd(); }
            });
        }

        function renderBoard(customState = null) {
            const board = document.getElementById('board');
            board.innerHTML = '';

            const state = customState || engine.board;
            const files = 'abcdefgh';

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const square = document.createElement('div');
                    const isLight = (r + c) % 2 === 0;
                    square.className = `square ${isLight ? 'light' : 'dark'}`;
                    square.dataset.row = r;
                    square.dataset.col = c;

                    // Highlights
                    if (!customState && engine.moveHistory.length > 0) {
                        const lastMove = engine.moveHistory[engine.moveHistory.length - 1];
                        if ((lastMove.from.row === r && lastMove.from.col === c) ||
                            (lastMove.to.row === r && lastMove.to.col === c)) {
                            square.classList.add('last-move');
                        }
                    }

                    if (selectedSquare && selectedSquare.row === r && selectedSquare.col === c) {
                        square.classList.add('selected');
                    }

                    if (legalMoves.some(m => m.to.row === r && m.to.col === c)) {
                        square.classList.add(state[r][c] ? 'legal-capture' : 'legal-move');
                    }

                    if (!customState && engine.isInCheck(engine.turn)) {
                        const kingPos = engine.getKingPosition(engine.turn);
                        if (kingPos && kingPos.row === r && kingPos.col === c) {
                            square.classList.add('check');
                        }
                    }

                    // Coordinates
                    if (c === 0) {
                        const rank = document.createElement('span');
                        rank.className = 'coordinate rank';
                        rank.textContent = 8 - r;
                        square.appendChild(rank);
                    }
                    if (r === 7) {
                        const file = document.createElement('span');
                        file.className = 'coordinate file';
                        file.textContent = files[c];
                        square.appendChild(file);
                    }

                    // Piece
                    const piece = state[r][c];
                    if (piece && !(dragging && dragStartSquare && dragStartSquare.row === r && dragStartSquare.col === c)) {
                        const img = document.createElement('img');
                        img.src = PIECE_IMAGES[piece];
                        img.className = 'piece';
                        img.draggable = false;
                        
                        img.addEventListener('mousedown', (e) => startDrag(e, r, c, piece));
                        square.appendChild(img);
                    }

                    square.addEventListener('click', () => handleSquareClick(r, c));
                    square.addEventListener('mouseup', (e) => endDrag(e, r, c));
                    board.appendChild(square);
                }
            }

            updateCapturedPieces();
            updatePlayerIndicators();
        }

        // Drag and Drop
        function startDrag(e, row, col, piece) {
            if (gameOver || reviewMode || engine.turn !== 'white') return;
            if (!engine.isWhite(engine.board[row][col])) return;

            e.preventDefault();
            
            dragging = true;
            dragStartSquare = { row, col };
            selectedSquare = { row, col };
            legalMoves = engine.generateLegalMoves().filter(m => m.from.row === row && m.from.col === col);

            // Create ghost piece
            ghostPiece = document.createElement('img');
            ghostPiece.src = PIECE_IMAGES[piece];
            ghostPiece.className = 'ghost-piece';
            document.body.appendChild(ghostPiece);
            
            moveGhostPiece(e);
            renderBoard();

            document.addEventListener('mousemove', moveGhostPiece);
            document.addEventListener('mouseup', dropPiece);
        }

        function moveGhostPiece(e) {
            if (ghostPiece) {
                ghostPiece.style.left = e.clientX + 'px';
                ghostPiece.style.top = e.clientY + 'px';
            }
        }

        function dropPiece(e) {
            document.removeEventListener('mousemove', moveGhostPiece);
            document.removeEventListener('mouseup', dropPiece);

            if (ghostPiece) {
                ghostPiece.remove();
                ghostPiece = null;
            }

            dragging = false;
            dragStartSquare = null;
        }

        function endDrag(e, row, col) {
            if (!dragging) return;
            
            const targetMove = legalMoves.find(m => m.to.row === row && m.to.col === col);
            if (targetMove) {
                if (targetMove.promotion) {
                    pendingPromotion = { ...targetMove };
                    showPromotionModal();
                } else {
                    makePlayerMove(targetMove);
                }
            }

            selectedSquare = null;
            legalMoves = [];
            dragging = false;
            dragStartSquare = null;
            
            if (ghostPiece) {
                ghostPiece.remove();
                ghostPiece = null;
            }
            
            renderBoard();
        }

        function handleSquareClick(row, col) {
            if (gameOver || reviewMode || dragging) return;
            if (engine.turn !== 'white') return;

            const piece = engine.board[row][col];
            const targetMove = legalMoves.find(m => m.to.row === row && m.to.col === col);

            if (targetMove) {
                if (targetMove.promotion) {
                    pendingPromotion = { ...targetMove };
                    showPromotionModal();
                    return;
                }
                makePlayerMove(targetMove);
                return;
            }

            if (piece && engine.isWhite(piece)) {
                selectedSquare = { row, col };
                legalMoves = engine.generateLegalMoves().filter(m => m.from.row === row && m.from.col === col);
            } else {
                selectedSquare = null;
                legalMoves = [];
            }

            renderBoard();
        }

        function showPromotionModal() {
            const modal = document.getElementById('promotionModal');
            const container = document.getElementById('promotionPieces');
            container.innerHTML = '';

            ['Q', 'R', 'B', 'N'].forEach(p => {
                const div = document.createElement('div');
                div.className = 'promotion-piece';
                const img = document.createElement('img');
                img.src = PIECE_IMAGES[p];
                div.appendChild(img);
                div.onclick = () => {
                    const promoMove = { ...pendingPromotion, promotion: p };
                    modal.classList.remove('active');
                    selectedSquare = null;
                    legalMoves = [];
                    makePlayerMove(promoMove);
                };
                container.appendChild(div);
            });

            modal.classList.add('active');
        }

        function makePlayerMove(move) {
            engine.makeMove(move);
            selectedSquare = null;
            legalMoves = [];
            renderBoard();
            updateMoveList();
            playSound('move');
            
            const eval_ = engine.evaluate() / 100;
            updateEvalBar(eval_);

            if (checkGameEnd()) return;
            setTimeout(makeAIMove, 300);
        }

        function makeAIMove() {
            if (gameOver) return;
            document.getElementById('thinkingIndicator').style.display = 'flex';

            setTimeout(() => {
                const result = ai.getBestMove(engine);
                document.getElementById('thinkingIndicator').style.display = 'none';

                if (result && result.move) {
                    const captured = engine.board[result.move.to.row][result.move.to.col];
                    engine.makeMove(result.move);
                    renderBoard();
                    updateMoveList();
                    playSound(captured ? 'capture' : 'move');
                    
                    const eval_ = engine.evaluate() / 100;
                    updateEvalBar(eval_);
                    checkGameEnd();
                }
            }, 100);
        }

        function playSound(type) {
            // Simple audio feedback using Web Audio API
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            
            osc.connect(gain);
            gain.connect(ctx.destination);
            
            if (type === 'move') {
                osc.frequency.value = 600;
                gain.gain.value = 0.1;
            } else if (type === 'capture') {
                osc.frequency.value = 400;
                gain.gain.value = 0.15;
            }
            
            osc.start();
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.1);
            osc.stop(ctx.currentTime + 0.1);
        }

        function checkGameEnd() {
            if (engine.isCheckmate()) {
                gameOver = true;
                const winner = engine.turn === 'white' ? 'Black' : 'White';
                const icon = engine.turn === 'white' ? 'ðŸ¤–' : 'ðŸ‘‘';
                showGameOver(icon, `${winner} Wins!`, 'Checkmate');
                return true;
            }

            const draw = engine.isDraw();
            if (draw) {
                gameOver = true;
                let message = 'Draw';
                if (draw === 'stalemate') message = 'Stalemate';
                else if (draw === 'fifty-move') message = 'Fifty-move rule';
                else if (draw === 'insufficient') message = 'Insufficient material';
                showGameOver('ðŸ¤', 'Draw', message);
                return true;
            }
            return false;
        }

        function showGameOver(icon, title, message) {
            document.getElementById('gameStatus').textContent = title;
            document.getElementById('gameOverIcon').textContent = icon;
            document.getElementById('gameOverTitle').textContent = title;
            document.getElementById('gameOverMessage').textContent = message;
            document.getElementById('gameOverModal').classList.add('active');
        }

        function closeModal() {
            document.querySelectorAll('.modal-overlay').forEach(m => m.classList.remove('active'));
        }

        function resign() {
            if (gameOver || engine.moveHistory.length === 0) return;
            gameOver = true;
            showGameOver('ðŸ³ï¸', 'You Resigned', 'Black wins by resignation');
        }

        function updateMoveList() {
            const container = document.getElementById('movesContainer');
            const moves = engine.moveHistory;

            if (moves.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">â™Ÿ</div>
                        <div class="empty-state-text">No moves yet.<br>Make your first move!</div>
                    </div>
                `;
                return;
            }

            container.innerHTML = '';
            const classIcons = { brilliant: '!!', great: '!', best: 'â˜…', excellent: 'â—‹', good: 'â—‹', book: 'ðŸ“–', inaccuracy: '?!', mistake: '?', miss: 'âœ—', blunder: '??' };

            for (let i = 0; i < moves.length; i += 2) {
                const row = document.createElement('div');
                row.className = 'move-row';

                const num = document.createElement('span');
                num.className = 'move-number';
                num.textContent = (i / 2 + 1) + '.';
                row.appendChild(num);

                // White move
                const whiteMove = document.createElement('span');
                whiteMove.className = 'move';
                if (moveAnalysis[i]) whiteMove.classList.add(moveAnalysis[i].classification + '-move');
                if (reviewMode && reviewMoveIndex === i) whiteMove.classList.add('current');
                
                if (moveAnalysis[i]) {
                    const icon = document.createElement('span');
                    icon.className = 'move-icon';
                    icon.textContent = classIcons[moveAnalysis[i].classification];
                    whiteMove.appendChild(icon);
                }
                whiteMove.appendChild(document.createTextNode(moves[i].notation));
                whiteMove.onclick = () => goToMove(i);
                row.appendChild(whiteMove);

                // Black move
                if (moves[i + 1]) {
                    const blackMove = document.createElement('span');
                    blackMove.className = 'move';
                    if (moveAnalysis[i + 1]) blackMove.classList.add(moveAnalysis[i + 1].classification + '-move');
                    if (reviewMode && reviewMoveIndex === i + 1) blackMove.classList.add('current');
                    
                    if (moveAnalysis[i + 1]) {
                        const icon = document.createElement('span');
                        icon.className = 'move-icon';
                        icon.textContent = classIcons[moveAnalysis[i + 1].classification];
                        blackMove.appendChild(icon);
                    }
                    blackMove.appendChild(document.createTextNode(moves[i + 1].notation));
                    blackMove.onclick = () => goToMove(i + 1);
                    row.appendChild(blackMove);
                }

                container.appendChild(row);
            }

            container.scrollTop = container.scrollHeight;
        }

        function updateEvalBar(eval_) {
            const bar = document.getElementById('evalBar');
            const textWhite = document.getElementById('evalTextWhite');
            const textBlack = document.getElementById('evalTextBlack');

            const clampedEval = Math.max(-10, Math.min(10, eval_));
            const percentage = 50 - (clampedEval / 10) * 50;
            
            bar.style.height = percentage + '%';

            if (eval_ > 0) {
                textWhite.textContent = '+' + eval_.toFixed(1);
                textBlack.textContent = '';
            } else if (eval_ < 0) {
                textWhite.textContent = '';
                textBlack.textContent = Math.abs(eval_).toFixed(1);
            } else {
                textWhite.textContent = '0.0';
                textBlack.textContent = '';
            }
        }

        function updateCapturedPieces() {
            const pieceOrder = { q: 0, r: 1, b: 2, n: 3, p: 4, Q: 0, R: 1, B: 2, N: 3, P: 4 };
            const values = { P: 1, N: 3, B: 3, R: 5, Q: 9, p: 1, n: 3, b: 3, r: 5, q: 9 };

            // Calculate material
            let whiteMaterial = 0, blackMaterial = 0;
            engine.capturedPieces.white.forEach(p => whiteMaterial += values[p] || 0);
            engine.capturedPieces.black.forEach(p => blackMaterial += values[p] || 0);
            const advantage = whiteMaterial - blackMaterial;

            // White captured (black pieces)
            const whiteContainer = document.getElementById('capturedWhite');
            const whiteCaptured = [...engine.capturedPieces.white].sort((a, b) => pieceOrder[a] - pieceOrder[b]);
            whiteContainer.innerHTML = whiteCaptured.map(p => 
                `<img src="${PIECE_IMAGES[p]}" class="captured-piece">`
            ).join('');
            if (advantage > 0) whiteContainer.innerHTML += `<span class="material-advantage">+${advantage}</span>`;

            // Black captured (white pieces)
            const blackContainer = document.getElementById('capturedBlack');
            const blackCaptured = [...engine.capturedPieces.black].sort((a, b) => pieceOrder[a] - pieceOrder[b]);
            blackContainer.innerHTML = blackCaptured.map(p => 
                `<img src="${PIECE_IMAGES[p]}" class="captured-piece">`
            ).join('');
            if (advantage < 0) blackContainer.innerHTML += `<span class="material-advantage">+${Math.abs(advantage)}</span>`;
        }

        function updatePlayerIndicators() {
            document.getElementById('whitePlayer').classList.toggle('active', engine.turn === 'white' && !gameOver);
            document.getElementById('blackPlayer').classList.toggle('active', engine.turn === 'black' && !gameOver);
            document.getElementById('whiteClock').classList.toggle('active', engine.turn === 'white' && !gameOver);
            document.getElementById('blackClock').classList.toggle('active', engine.turn === 'black' && !gameOver);
        }

        function newGame() {
            engine = new ChessEngine();
            gameOver = false;
            reviewMode = false;
            selectedSquare = null;
            legalMoves = [];
            moveAnalysis = [];
            reviewMoveIndex = -1;
            
            closeModal();
            renderBoard();
            updateMoveList();
            updateEvalBar(0);
            document.getElementById('gameStatus').textContent = '';
            showPanelTab('moves');
            
            document.getElementById('playTab').classList.add('active');
            document.getElementById('reviewTab').classList.remove('active');
        }

        function showGame() {
            document.getElementById('playTab').classList.add('active');
            document.getElementById('reviewTab').classList.remove('active');
            reviewMode = false;
            reviewMoveIndex = -1;
            renderBoard();
            clearArrows();
        }

        function showPanelTab(tab) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.tab:nth-child(${tab === 'moves' ? 1 : 2})`).classList.add('active');
            
            document.getElementById('movesPanel').style.display = tab === 'moves' ? 'flex' : 'none';
            document.getElementById('reviewPanel').style.display = tab === 'review' ? 'block' : 'none';
            document.getElementById('reviewPanel').classList.toggle('active', tab === 'review');
        }

        function startReview() {
            if (engine.moveHistory.length === 0) {
                alert('Play a game first to use Game Review!');
                return;
            }

            document.getElementById('playTab').classList.remove('active');
            document.getElementById('reviewTab').classList.add('active');
            showPanelTab('review');
            
            const content = document.getElementById('reviewContent');
            content.innerHTML = `
                <div class="analyzing-container">
                    <div class="spinner"></div>
                    <div class="analyzing-text">Analyzing your game...</div>
                    <div class="analyzing-subtext">This may take a moment</div>
                </div>
            `;

            setTimeout(analyzeGame, 100);
        }

        function analyzeGame() {
            moveAnalysis = [];
            const tempEngine = new ChessEngine();
            const analyzeAI = new ChessAI(4);

            for (let i = 0; i < engine.moveHistory.length; i++) {
                const move = engine.moveHistory[i];
                const color = i % 2 === 0 ? 'white' : 'black';
                const analysis = analyzeAI.analyzeMove(tempEngine, move, color);
                moveAnalysis.push(analysis);
                tempEngine.makeMove(move, true);
            }

            showReviewResults();
            reviewMode = true;
            reviewMoveIndex = -1;
            updateMoveList();
        }

        function showReviewResults() {
            const content = document.getElementById('reviewContent');
            
            const whiteAnalysis = moveAnalysis.filter((_, i) => i % 2 === 0);
            const blackAnalysis = moveAnalysis.filter((_, i) => i % 2 === 1);
            
            const calcAccuracy = (analyses) => {
                if (analyses.length === 0) return 100;
                let total = 0;
                for (const a of analyses) {
                    let acc = 100;
                    switch (a.classification) {
                        case 'brilliant': case 'great': case 'best': acc = 100; break;
                        case 'excellent': acc = 95; break;
                        case 'good': acc = 87; break;
                        case 'book': acc = 92; break;
                        case 'inaccuracy': acc = 52; break;
                        case 'mistake': acc = 26; break;
                        case 'miss': acc = 15; break;
                        case 'blunder': acc = 0; break;
                    }
                    total += acc;
                }
                return Math.round(total / analyses.length);
            };

            const whiteAccuracy = calcAccuracy(whiteAnalysis);
            const blackAccuracy = calcAccuracy(blackAnalysis);
            const countClass = (analyses, cls) => analyses.filter(a => a.classification === cls).length;

            const classifications = [
                { key: 'brilliant', name: 'Brilliant', icon: '!!' },
                { key: 'great', name: 'Great Move', icon: '!' },
                { key: 'best', name: 'Best Move', icon: 'â˜…' },
                { key: 'excellent', name: 'Excellent', icon: 'â—‹' },
                { key: 'good', name: 'Good', icon: 'â—‹' },
                { key: 'book', name: 'Book', icon: 'ðŸ“–' },
                { key: 'inaccuracy', name: 'Inaccuracy', icon: '?!' },
                { key: 'mistake', name: 'Mistake', icon: '?' },
                { key: 'blunder', name: 'Blunder', icon: '??' }
            ];

            const circumference = 2 * Math.PI * 46;

            content.innerHTML = `
                <div class="accuracy-section">
                    <div class="accuracy-row">
                        <div class="accuracy-item">
                            <div class="accuracy-ring white">
                                <svg viewBox="0 0 100 100">
                                    <circle class="bg" cx="50" cy="50" r="46"/>
                                    <circle class="progress" cx="50" cy="50" r="46" 
                                        stroke-dasharray="${circumference}" 
                                        stroke-dashoffset="${circumference * (1 - whiteAccuracy / 100)}"/>
                                </svg>
                                <div class="accuracy-value">${whiteAccuracy}</div>
                            </div>
                            <div class="accuracy-label">Your Accuracy</div>
                        </div>
                        <div class="accuracy-item">
                            <div class="accuracy-ring black">
                                <svg viewBox="0 0 100 100">
                                    <circle class="bg" cx="50" cy="50" r="46"/>
                                    <circle class="progress" cx="50" cy="50" r="46" 
                                        stroke-dasharray="${circumference}" 
                                        stroke-dashoffset="${circumference * (1 - blackAccuracy / 100)}"/>
                                </svg>
                                <div class="accuracy-value">${blackAccuracy}</div>
                            </div>
                            <div class="accuracy-label">Bot Accuracy</div>
                        </div>
                    </div>
                </div>
                <div class="classification-section">
                    <div class="classification-header">
                        <span>White</span>
                        <span>Black</span>
                    </div>
                    ${classifications.map(c => {
                        const wCount = countClass(whiteAnalysis, c.key);
                        const bCount = countClass(blackAnalysis, c.key);
                        return `
                            <div class="classification-row">
                                <div class="classification-label">
                                    <div class="classification-icon ${c.key}">${c.icon}</div>
                                    <span class="classification-name">${c.name}</span>
                                </div>
                                <div class="classification-counts">
                                    <span class="count-badge ${wCount > 0 ? 'has-value' : ''}">${wCount}</span>
                                    <span class="count-badge ${bCount > 0 ? 'has-value' : ''}">${bCount}</span>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
                <div id="reviewMoveInfo"></div>
            `;
        }

        function goToMove(index) {
            if (index < -1 || index >= engine.moveHistory.length) return;
            
            reviewMoveIndex = index;
            
            if (index === -1) {
                const initialEngine = new ChessEngine();
                renderBoard(initialEngine.board);
                updateEvalBar(0);
                clearArrows();
            } else {
                const state = engine.moveHistory[index].boardState;
                renderBoard(state.board);
                
                if (moveAnalysis[index]) {
                    updateEvalBar(moveAnalysis[index].evalAfter);
                    showMoveInfo(index);
                    if (moveAnalysis[index].bestMove && !moveAnalysis[index].isBestMove) {
                        drawArrow(moveAnalysis[index].bestMove);
                    } else {
                        clearArrows();
                    }
                }
            }

            updateMoveList();
        }

        function showMoveInfo(index) {
            const info = document.getElementById('reviewMoveInfo');
            if (!info || !moveAnalysis[index]) return;

            const analysis = moveAnalysis[index];
            const move = engine.moveHistory[index];
            
            const classData = {
                brilliant: { icon: '!!', name: 'Brilliant' },
                great: { icon: '!', name: 'Great Move' },
                best: { icon: 'â˜…', name: 'Best Move' },
                excellent: { icon: 'â—‹', name: 'Excellent' },
                good: { icon: 'â—‹', name: 'Good' },
                book: { icon: 'ðŸ“–', name: 'Book' },
                inaccuracy: { icon: '?!', name: 'Inaccuracy' },
                mistake: { icon: '?', name: 'Mistake' },
                miss: { icon: 'âœ—', name: 'Miss' },
                blunder: { icon: '??', name: 'Blunder' }
            };

            const cls = classData[analysis.classification];
            const files = 'abcdefgh';

            info.innerHTML = `
                <div class="review-move-info">
                    <div class="review-move-header">
                        <div class="review-move-class">
                            <div class="classification-icon ${analysis.classification}">${cls.icon}</div>
                            <span class="review-move-notation">${move.notation}</span>
                            <span style="color: var(--text-muted); font-size: 13px;">${cls.name}</span>
                        </div>
                        <span class="eval-change ${analysis.evalChange >= 0 ? 'positive' : 'negative'}">
                            ${analysis.evalChange >= 0 ? '+' : ''}${analysis.evalChange.toFixed(2)}
                        </span>
                    </div>
                    ${!analysis.isBestMove && analysis.bestMove ? `
                        <div class="review-best-move">
                            Best move was <strong>${files[analysis.bestMove.from.col]}${8 - analysis.bestMove.from.row}${files[analysis.bestMove.to.col]}${8 - analysis.bestMove.to.row}</strong>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        function drawArrow(move) {
            const svg = document.getElementById('arrowOverlay');
            const squareSize = 80;
            
            const fromX = move.from.col * squareSize + squareSize / 2;
            const fromY = move.from.row * squareSize + squareSize / 2;
            const toX = move.to.col * squareSize + squareSize / 2;
            const toY = move.to.row * squareSize + squareSize / 2;

            const angle = Math.atan2(toY - fromY, toX - fromX);
            const headLen = 20;
            
            const endX = toX - Math.cos(angle) * 15;
            const endY = toY - Math.sin(angle) * 15;
            
            svg.innerHTML = `
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="rgba(129, 182, 76, 0.9)"/>
                    </marker>
                </defs>
                <line x1="${fromX}" y1="${fromY}" x2="${endX}" y2="${endY}" 
                    stroke="rgba(129, 182, 76, 0.9)" stroke-width="12" stroke-linecap="round"
                    marker-end="url(#arrowhead)"/>
            `;
        }

        function clearArrows() {
            document.getElementById('arrowOverlay').innerHTML = '';
        }

        function goToStart() { goToMove(-1); }
        function goBack() { goToMove(Math.max(-1, reviewMoveIndex - 1)); }
        function goForward() { goToMove(Math.min(engine.moveHistory.length - 1, reviewMoveIndex + 1)); }
        function goToEnd() { goToMove(engine.moveHistory.length - 1); }

        // Initialize
        init();
    </script>
</body>
</html>
