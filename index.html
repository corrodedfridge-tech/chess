<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-font-smoothing: antialiased;
        }

        :root {
            --bg-darkest: #262421;
            --bg-darker: #302e2b;
            --bg-dark: #3d3b38;
            --bg-medium: #4a4847;
            --bg-light: #5d5b59;
            --accent-green: #81b64c;
            --accent-green-hover: #9aca5f;
            --accent-green-dark: #629924;
            --text-white: #ffffff;
            --text-light: #bababa;
            --text-muted: #888888;
            --light-square: #ebecd0;
            --dark-square: #779556;
            --highlight-yellow: rgba(255, 255, 0, 0.5);
            --highlight-move: rgba(255, 255, 0, 0.5);
            --check-red: radial-gradient(ellipse at center, rgba(255,0,0,0.9) 0%, rgba(255,0,0,0.5) 35%, rgba(255,0,0,0) 65%);
            --brilliant: #1baca6;
            --great: #5c8bb0;
            --best: #98bc4b;
            --excellent: #96bc4b;
            --good: #96af8b;
            --book: #a88865;
            --inaccuracy: #f7c631;
            --mistake: #e69d00;
            --miss: #df5f5b;
            --blunder: #ca3431;
        }

        body {
            font-family: 'Montserrat', sans-serif;
            background: var(--bg-darkest);
            min-height: 100vh;
            color: var(--text-white);
            overflow-x: hidden;
        }

        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes slideUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 20% { transform: translateX(-8px); } 40% { transform: translateX(8px); } 60% { transform: translateX(-8px); } 80% { transform: translateX(8px); } }
        @keyframes popIn { 0% { transform: scale(0); } 70% { transform: scale(1.2); } 100% { transform: scale(1); } }
        @keyframes captureFlash { 0% { background: rgba(255, 100, 100, 0.7); } 100% { background: transparent; } }
        @keyframes checkPulse { 0%, 100% { box-shadow: inset 0 0 30px rgba(255, 0, 0, 0.6); } 50% { box-shadow: inset 0 0 60px rgba(255, 0, 0, 0.9); } }
        @keyframes moveIconPop { 0% { transform: scale(0) rotate(-180deg); } 60% { transform: scale(1.3) rotate(10deg); } 100% { transform: scale(1) rotate(0deg); } }
        @keyframes kingFall { 0% { transform: rotate(0deg) scale(1); } 30% { transform: rotate(-15deg) scale(1); } 100% { transform: rotate(-90deg) scale(0.8) translateY(20px); opacity: 0.5; } }
        @keyframes explode { 0% { transform: scale(0); opacity: 1; } 100% { transform: scale(3); opacity: 0; } }
        @keyframes particle { 0% { transform: translate(0, 0) scale(1); opacity: 1; } 100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; } }
        @keyframes victoryGlow { 0%, 100% { box-shadow: 0 0 30px rgba(129, 182, 76, 0.5); } 50% { box-shadow: 0 0 60px rgba(129, 182, 76, 0.8); } }
        @keyframes shimmer { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }
        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-5px); } }
        @keyframes sparkle { 0%, 100% { opacity: 0; transform: scale(0); } 50% { opacity: 1; transform: scale(1); } }

        .shake { animation: shake 0.4s ease-in-out; }
        .king-fallen { animation: kingFall 0.8s ease-in forwards; }
        .victory-glow { animation: victoryGlow 1.5s ease infinite; }

        .header {
            background: linear-gradient(180deg, #302e2b 0%, #272522 100%);
            padding: 12px 24px;
            display: flex;
            align-items: center;
            gap: 24px;
            border-bottom: 1px solid rgba(255,255,255,0.08);
            box-shadow: 0 2px 12px rgba(0,0,0,0.4);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 22px;
            font-weight: 800;
            color: var(--text-white);
            text-decoration: none;
        }

        .logo-icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, var(--accent-green) 0%, var(--accent-green-dark) 100%);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            box-shadow: 0 4px 12px rgba(129, 182, 76, 0.4);
            transition: all 0.3s ease;
        }

        .logo:hover .logo-icon {
            transform: rotate(-10deg) scale(1.1);
        }

        .nav-tabs {
            display: flex;
            gap: 4px;
            background: var(--bg-dark);
            padding: 4px;
            border-radius: 10px;
        }

        .nav-btn {
            background: transparent;
            border: none;
            color: var(--text-light);
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            font-family: inherit;
            transition: all 0.2s ease;
        }

        .nav-btn:hover { background: var(--bg-medium); color: var(--text-white); }
        .nav-btn.active {
            background: linear-gradient(135deg, var(--accent-green) 0%, var(--accent-green-dark) 100%);
            color: var(--text-white);
            box-shadow: 0 4px 15px rgba(129, 182, 76, 0.5);
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-left: auto;
        }

        .elo-container {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .elo-label {
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .elo-display {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .elo-value {
            font-size: 18px;
            font-weight: 800;
            min-width: 50px;
            color: var(--accent-green);
        }

        .elo-slider {
            width: 180px;
            height: 6px;
            -webkit-appearance: none;
            background: var(--bg-dark);
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }

        .elo-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, var(--accent-green), var(--accent-green-dark));
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            transition: transform 0.2s;
        }

        .elo-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .elo-description {
            font-size: 10px;
            color: var(--text-muted);
            max-width: 120px;
        }

        .main-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 30px;
            gap: 24px;
            max-width: 1400px;
            margin: 0 auto;
            animation: fadeIn 0.5s ease;
        }

        .board-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .board-wrapper {
            display: flex;
            gap: 10px;
            position: relative;
        }

        .board-container {
            position: relative;
            border-radius: 6px;
            overflow: hidden;
            box-shadow: 0 12px 40px rgba(0,0,0,0.6);
            transition: all 0.3s ease;
        }

        .board {
            width: 640px;
            height: 640px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            position: relative;
        }

        .square {
            width: 80px;
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .square.light { background: var(--light-square); }
        .square.dark { background: var(--dark-square); }
        .square.selected { background: var(--highlight-yellow) !important; }
        .square.last-move { background: var(--highlight-move) !important; }
        
        .square.legal-move::after {
            content: '';
            width: 26px;
            height: 26px;
            background: rgba(0, 0, 0, 0.18);
            border-radius: 50%;
            position: absolute;
            transition: all 0.2s ease;
        }

        .square.legal-move:hover::after { transform: scale(1.3); background: rgba(0, 0, 0, 0.25); }

        .square.legal-capture::after {
            content: '';
            width: 100%;
            height: 100%;
            border: 7px solid rgba(0, 0, 0, 0.18);
            border-radius: 50%;
            position: absolute;
            box-sizing: border-box;
        }

        .square.check { background: var(--check-red) !important; animation: checkPulse 1s ease infinite; }
        .square.capture-flash { animation: captureFlash 0.3s ease; }

        .move-classification-icon {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 26px;
            height: 26px;
            z-index: 20;
            animation: moveIconPop 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
            pointer-events: none;
        }

        .piece {
            width: 88%;
            height: 88%;
            cursor: grab;
            z-index: 10;
            transition: transform 0.15s ease, filter 0.15s ease;
            user-select: none;
            -webkit-user-drag: none;
            filter: drop-shadow(2px 4px 4px rgba(0,0,0,0.4));
        }

        .piece:hover { transform: scale(1.08); filter: drop-shadow(3px 6px 8px rgba(0,0,0,0.5)); }
        .piece.dragging { cursor: grabbing; transform: scale(1.2); z-index: 1000; }

        .ghost-piece {
            position: fixed;
            pointer-events: none;
            z-index: 10000;
            width: 100px;
            height: 100px;
            filter: drop-shadow(6px 12px 12px rgba(0,0,0,0.6));
            transform: translate(-50%, -50%);
        }

        .coordinate {
            position: absolute;
            font-size: 11px;
            font-weight: 700;
            pointer-events: none;
            user-select: none;
            opacity: 0.8;
        }

        .coordinate.file { bottom: 2px; right: 4px; }
        .coordinate.rank { top: 2px; left: 4px; }
        .square.light .coordinate { color: var(--dark-square); }
        .square.dark .coordinate { color: var(--light-square); }

        .eval-bar-container {
            width: 30px;
            height: 640px;
            background: linear-gradient(180deg, #1a1a1a 0%, #333 100%);
            border-radius: 6px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
        }

        .eval-bar-white {
            width: 100%;
            background: linear-gradient(180deg, #ffffff 0%, #e8e8e8 100%);
            position: absolute;
            bottom: 0;
            transition: height 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .eval-text {
            position: absolute;
            width: 100%;
            text-align: center;
            font-size: 10px;
            font-weight: 700;
            padding: 5px 0;
        }

        .eval-text.white { bottom: 0; color: #1a1a1a; }
        .eval-text.black { top: 0; color: #ffffff; }

        .captured-pieces {
            height: 32px;
            display: flex;
            align-items: center;
            gap: 1px;
            padding: 0 8px;
            min-height: 32px;
        }

        .captured-piece {
            width: 22px;
            height: 22px;
            opacity: 0.85;
            transition: transform 0.2s ease;
            animation: popIn 0.3s ease;
        }

        .captured-piece:hover { transform: scale(1.3); opacity: 1; z-index: 10; }

        .material-advantage {
            font-size: 14px;
            font-weight: 700;
            color: var(--text-white);
            margin-left: 8px;
            background: var(--bg-dark);
            padding: 2px 8px;
            border-radius: 4px;
            animation: popIn 0.3s ease;
        }

        .side-panel {
            background: var(--bg-darker);
            border-radius: 12px;
            width: 380px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            display: flex;
            flex-direction: column;
            animation: slideUp 0.4s ease;
        }

        .panel-section { border-bottom: 1px solid rgba(255,255,255,0.06); }

        .player-info {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 16px 18px;
            background: var(--bg-dark);
            transition: all 0.3s ease;
            position: relative;
        }

        .player-info::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 4px;
            background: transparent;
            transition: all 0.3s ease;
        }

        .player-info.active::before { background: var(--accent-green); box-shadow: 0 0 20px var(--accent-green); }
        .player-info.active { background: linear-gradient(90deg, rgba(129, 182, 76, 0.15) 0%, var(--bg-dark) 100%); }

        .player-avatar {
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, var(--bg-medium) 0%, var(--bg-dark) 100%);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
        }

        .player-info.active .player-avatar { animation: pulse 2s ease infinite; }

        .player-details { flex: 1; }
        .player-name { font-weight: 700; font-size: 15px; }
        .player-rating { color: var(--text-muted); font-size: 12px; margin-top: 3px; }

        .player-clock {
            background: var(--bg-darkest);
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 22px;
            font-weight: 700;
            font-variant-numeric: tabular-nums;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .player-clock.active {
            background: linear-gradient(135deg, var(--accent-green) 0%, var(--accent-green-dark) 100%);
            color: var(--text-white);
            box-shadow: 0 4px 20px rgba(129, 182, 76, 0.5);
        }

        .tab-container {
            display: flex;
            background: var(--bg-darkest);
            padding: 6px;
            gap: 4px;
        }

        .tab {
            flex: 1;
            padding: 12px 16px;
            text-align: center;
            cursor: pointer;
            background: transparent;
            border: none;
            color: var(--text-muted);
            font-size: 13px;
            font-weight: 600;
            font-family: inherit;
            transition: all 0.2s ease;
            border-radius: 6px;
        }

        .tab:hover { color: var(--text-light); background: var(--bg-dark); }
        .tab.active { color: var(--text-white); background: var(--bg-medium); }

        .moves-section {
            flex: 1;
            min-height: 260px;
            max-height: 320px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .moves-container {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }

        .moves-container::-webkit-scrollbar { width: 6px; }
        .moves-container::-webkit-scrollbar-track { background: var(--bg-darkest); border-radius: 3px; }
        .moves-container::-webkit-scrollbar-thumb { background: var(--bg-medium); border-radius: 3px; }

        .move-row { display: flex; align-items: center; padding: 2px 0; }
        .move-number { width: 32px; color: var(--text-muted); font-size: 12px; font-weight: 600; text-align: center; }

        .move {
            flex: 1;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .move:hover { background: var(--bg-dark); transform: translateX(2px); }
        .move.current { background: var(--bg-medium); box-shadow: inset 3px 0 0 var(--accent-green); }

        .move-icon {
            width: 20px;
            height: 20px;
            flex-shrink: 0;
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.3));
        }

        .game-status {
            text-align: center;
            padding: 16px;
            font-size: 16px;
            font-weight: 700;
            color: var(--accent-green);
            background: linear-gradient(180deg, transparent 0%, rgba(129, 182, 76, 0.1) 100%);
        }

        .thinking {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            padding: 14px 18px;
            color: var(--text-muted);
            background: linear-gradient(90deg, var(--bg-darkest) 0%, var(--bg-dark) 50%, var(--bg-darkest) 100%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            font-size: 13px;
        }

        .thinking-dots { display: flex; gap: 5px; }
        .thinking-dots span {
            width: 8px;
            height: 8px;
            background: var(--accent-green);
            border-radius: 50%;
            animation: pulse 1.2s infinite;
        }
        .thinking-dots span:nth-child(2) { animation-delay: 0.15s; }
        .thinking-dots span:nth-child(3) { animation-delay: 0.3s; }

        .game-controls {
            display: flex;
            gap: 8px;
            padding: 16px 18px;
            justify-content: center;
            background: var(--bg-darkest);
            border-top: 1px solid rgba(255,255,255,0.06);
        }

        .control-btn {
            background: var(--bg-dark);
            border: none;
            color: var(--text-light);
            width: 48px;
            height: 48px;
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.15s ease;
        }

        .control-btn:hover { background: var(--bg-medium); color: var(--text-white); transform: translateY(-2px); }
        .control-btn:active { transform: translateY(0) scale(0.95); }
        .control-btn:disabled { opacity: 0.3; cursor: not-allowed; }
        .control-btn svg { width: 20px; height: 20px; fill: currentColor; }

        .action-buttons { padding: 16px 18px; display: flex; gap: 12px; }

        .new-game-btn {
            flex: 1;
            background: linear-gradient(135deg, var(--accent-green) 0%, var(--accent-green-dark) 100%);
            border: none;
            color: var(--text-white);
            padding: 16px 28px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 15px;
            font-weight: 700;
            font-family: inherit;
            transition: all 0.2s ease;
            box-shadow: 0 4px 16px rgba(129, 182, 76, 0.4);
        }

        .new-game-btn:hover { transform: translateY(-2px); box-shadow: 0 8px 24px rgba(129, 182, 76, 0.5); }

        .resign-btn {
            background: var(--bg-dark);
            border: 2px solid var(--bg-medium);
            color: var(--text-light);
            padding: 16px 22px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            font-family: inherit;
            transition: all 0.2s ease;
        }

        .resign-btn:hover { background: var(--blunder); border-color: var(--blunder); color: var(--text-white); }

        .review-panel { display: none; animation: fadeIn 0.3s ease; }
        .review-panel.active { display: block; }

        .accuracy-section {
            padding: 28px;
            background: linear-gradient(180deg, var(--bg-darkest) 0%, var(--bg-darker) 100%);
        }

        .accuracy-row { display: flex; justify-content: center; gap: 50px; }
        .accuracy-item { text-align: center; }

        .accuracy-ring {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            position: relative;
            margin: 0 auto 14px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .accuracy-ring svg { position: absolute; width: 100%; height: 100%; transform: rotate(-90deg); }
        .accuracy-ring circle { fill: none; stroke-width: 10; }
        .accuracy-ring .bg { stroke: var(--bg-dark); }
        .accuracy-ring .progress { stroke-linecap: round; transition: stroke-dashoffset 1.5s cubic-bezier(0.4, 0, 0.2, 1); }
        .accuracy-ring.white .progress { stroke: var(--text-white); filter: drop-shadow(0 0 8px rgba(255,255,255,0.5)); }
        .accuracy-ring.black .progress { stroke: var(--text-muted); }

        .accuracy-value { font-size: 32px; font-weight: 800; }
        .accuracy-percent { font-size: 14px; font-weight: 600; opacity: 0.7; }
        .accuracy-label { font-size: 12px; color: var(--text-muted); font-weight: 600; text-transform: uppercase; letter-spacing: 1px; }

        .classification-section { padding: 0 18px 18px; }
        .classification-header { display: flex; justify-content: flex-end; padding: 12px 0; gap: 10px; font-size: 11px; font-weight: 700; color: var(--text-muted); text-transform: uppercase; }
        .classification-header span { width: 44px; text-align: center; }

        .classification-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255,255,255,0.04);
            transition: background 0.2s ease;
        }
        .classification-row:hover { background: rgba(255,255,255,0.02); }

        .classification-label { display: flex; align-items: center; gap: 12px; }
        .classification-icon { width: 28px; height: 28px; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3)); }
        .classification-name { font-size: 13px; font-weight: 600; }
        .classification-counts { display: flex; gap: 10px; }

        .count-badge {
            width: 44px;
            text-align: center;
            font-size: 14px;
            font-weight: 700;
            padding: 6px 0;
            border-radius: 6px;
            background: var(--bg-dark);
        }
        .count-badge.has-value { background: var(--bg-medium); }

        .review-move-info {
            background: var(--bg-dark);
            margin: 16px;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 16px rgba(0,0,0,0.2);
            animation: slideUp 0.3s ease;
        }

        .review-move-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 18px;
            background: var(--bg-darkest);
        }

        .review-move-class { display: flex; align-items: center; gap: 12px; }
        .review-move-icon { width: 28px; height: 28px; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3)); }
        .review-move-notation { font-size: 18px; font-weight: 700; }
        .review-move-type { font-size: 13px; color: var(--text-muted); }

        .eval-change { font-size: 14px; font-weight: 700; padding: 6px 12px; border-radius: 6px; }
        .eval-change.positive { background: rgba(129, 182, 76, 0.2); color: var(--accent-green); }
        .eval-change.negative { background: rgba(202, 52, 49, 0.2); color: var(--blunder); }

        .review-best-move { padding: 14px 18px; font-size: 13px; color: var(--text-muted); border-top: 1px solid rgba(255,255,255,0.05); }
        .review-best-move strong { color: var(--accent-green); font-weight: 700; }

        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(8px);
        }

        .modal-overlay.active { display: flex; animation: fadeIn 0.25s ease; }

        .modal {
            background: linear-gradient(180deg, var(--bg-darker) 0%, var(--bg-darkest) 100%);
            padding: 40px 50px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 32px 100px rgba(0, 0, 0, 0.7);
            animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            max-width: 480px;
            position: relative;
            overflow: hidden;
        }

        .modal-icon {
            width: 100px;
            height: 100px;
            background: linear-gradient(135deg, var(--bg-dark) 0%, var(--bg-darkest) 100%);
            border-radius: 50%;
            margin: 0 auto 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 50px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            position: relative;
        }

        .modal-icon.victory { animation: victoryGlow 1.5s ease infinite; }

        .modal-title { font-size: 32px; font-weight: 800; margin-bottom: 12px; }
        .modal-subtitle { color: var(--text-muted); font-size: 16px; margin-bottom: 32px; line-height: 1.5; }

        .modal-buttons { display: flex; gap: 12px; justify-content: center; }

        .modal-btn {
            padding: 16px 32px;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 700;
            font-family: inherit;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
        }

        .modal-btn.primary {
            background: linear-gradient(135deg, var(--accent-green) 0%, var(--accent-green-dark) 100%);
            color: var(--text-white);
            box-shadow: 0 4px 16px rgba(129, 182, 76, 0.4);
        }
        .modal-btn.primary:hover { transform: translateY(-2px); box-shadow: 0 8px 24px rgba(129, 182, 76, 0.5); }

        .modal-btn.secondary { background: var(--bg-dark); color: var(--text-light); border: 2px solid var(--bg-medium); }
        .modal-btn.secondary:hover { background: var(--bg-medium); color: var(--text-white); }

        .promotion-modal .modal { padding: 28px; }
        .promotion-title { font-size: 16px; font-weight: 700; margin-bottom: 20px; color: var(--text-light); }
        .promotion-pieces { display: flex; gap: 10px; }

        .promotion-piece {
            width: 85px;
            height: 85px;
            background: linear-gradient(135deg, var(--bg-dark) 0%, var(--bg-medium) 100%);
            border-radius: 12px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.2s ease;
            border: 3px solid transparent;
        }

        .promotion-piece:hover {
            border-color: var(--accent-green);
            transform: scale(1.08) translateY(-4px);
        }

        .promotion-piece img { width: 70px; height: 70px; }

        .particles-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
            overflow: hidden;
        }

        .particle {
            position: absolute;
            border-radius: 50%;
            animation: particle 1s ease-out forwards;
        }

        .explosion-ring {
            position: absolute;
            border: 4px solid var(--accent-green);
            border-radius: 50%;
            animation: explode 0.6s ease-out forwards;
        }

        .empty-state { padding: 50px; text-align: center; color: var(--text-muted); }
        .empty-state-icon { font-size: 56px; margin-bottom: 16px; opacity: 0.4; }
        .empty-state-text { font-size: 14px; line-height: 1.7; }

        .analyzing-container { padding: 70px 40px; text-align: center; }
        .spinner {
            width: 56px;
            height: 56px;
            border: 5px solid var(--bg-dark);
            border-top: 5px solid var(--accent-green);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin: 0 auto 24px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .analyzing-text { font-size: 18px; font-weight: 700; margin-bottom: 8px; }
        .analyzing-subtext { font-size: 13px; color: var(--text-muted); }

        @media (max-width: 1100px) {
            .main-container { flex-direction: column; align-items: center; padding: 20px; }
            .board { width: 560px; height: 560px; }
            .square { width: 70px; height: 70px; }
            .eval-bar-container { height: 560px; }
            .side-panel { width: 100%; max-width: 560px; }
        }
    </style>
</head>
<body>
    <div class="particles-container" id="particles"></div>

    <header class="header">
        <a href="#" class="logo">
            <div class="logo-icon">â™ž</div>
            <span>Chess</span>
        </a>
        
        <div class="nav-tabs">
            <button class="nav-btn active" id="playTab" onclick="showGame()">Play</button>
            <button class="nav-btn" id="reviewTabBtn" onclick="startReview()">Game Review</button>
        </div>

        <div class="header-controls">
            <div class="elo-container">
                <span class="elo-label">Bot Strength</span>
                <div class="elo-display">
                    <span class="elo-value" id="eloDisplay">1500</span>
                    <input type="range" class="elo-slider" id="eloSlider" min="0" max="3200" step="100" value="1500">
                </div>
                <span class="elo-description" id="eloDesc">Intermediate</span>
            </div>
        </div>
    </header>

    <main class="main-container">
        <section class="board-section">
            <div class="captured-pieces" id="capturedBlack"></div>
            
            <div class="board-wrapper">
                <div class="eval-bar-container">
                    <div class="eval-bar-white" id="evalBar" style="height: 50%;"></div>
                    <div class="eval-text white" id="evalTextWhite">0.0</div>
                    <div class="eval-text black" id="evalTextBlack"></div>
                </div>
                
                <div class="board-container" id="boardContainer">
                    <div class="board" id="board"></div>
                </div>
            </div>
            
            <div class="captured-pieces" id="capturedWhite"></div>
        </section>

        <aside class="side-panel">
            <div class="player-info panel-section" id="blackPlayer">
                <div class="player-avatar">ðŸ¤–</div>
                <div class="player-details">
                    <div class="player-name" id="botName">Chess Bot</div>
                    <div class="player-rating" id="botRating">ELO 1500</div>
                </div>
                <div class="player-clock" id="blackClock">10:00</div>
            </div>

            <div class="thinking" id="thinkingIndicator" style="display: none;">
                <span>Thinking</span>
                <div class="thinking-dots"><span></span><span></span><span></span></div>
            </div>

            <div class="tab-container panel-section">
                <button class="tab active" onclick="showPanelTab('moves')">Moves</button>
                <button class="tab" onclick="showPanelTab('review')">Analysis</button>
            </div>

            <div id="movesPanel" class="moves-section">
                <div class="moves-container" id="movesContainer">
                    <div class="empty-state">
                        <div class="empty-state-icon">â™Ÿ</div>
                        <div class="empty-state-text">No moves yet.<br>Make your first move!</div>
                    </div>
                </div>
            </div>

            <div id="reviewPanel" class="review-panel">
                <div id="reviewContent">
                    <div class="empty-state">
                        <div class="empty-state-icon">ðŸ“Š</div>
                        <div class="empty-state-text">Play a game first, then click<br>"Game Review" to analyze.</div>
                    </div>
                </div>
            </div>

            <div class="game-status" id="gameStatus"></div>

            <div class="game-controls panel-section">
                <button class="control-btn" onclick="goToStart()" title="Start">
                    <svg viewBox="0 0 24 24"><path d="M18.41 16.59L13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z"/></svg>
                </button>
                <button class="control-btn" onclick="goBack()" title="Back">
                    <svg viewBox="0 0 24 24"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/></svg>
                </button>
                <button class="control-btn" onclick="goForward()" title="Forward">
                    <svg viewBox="0 0 24 24"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/></svg>
                </button>
                <button class="control-btn" onclick="goToEnd()" title="End">
                    <svg viewBox="0 0 24 24"><path d="M5.59 7.41L10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z"/></svg>
                </button>
            </div>

            <div class="player-info panel-section" id="whitePlayer">
                <div class="player-avatar">ðŸ‘¤</div>
                <div class="player-details">
                    <div class="player-name">You</div>
                    <div class="player-rating">Playing as White</div>
                </div>
                <div class="player-clock active" id="whiteClock">10:00</div>
            </div>

            <div class="action-buttons">
                <button class="new-game-btn" onclick="newGame()">New Game</button>
                <button class="resign-btn" onclick="resign()">Resign</button>
            </div>
        </aside>
    </main>

    <div class="modal-overlay" id="gameOverModal">
        <div class="modal">
            <div class="modal-icon" id="gameOverIcon">ðŸ‘‘</div>
            <h2 class="modal-title" id="gameOverTitle">Game Over</h2>
            <p class="modal-subtitle" id="gameOverMessage">You won by checkmate!</p>
            <div class="modal-buttons">
                <button class="modal-btn primary" onclick="newGame()">Play Again</button>
                <button class="modal-btn secondary" onclick="closeModal(); startReview();">Review Game</button>
            </div>
        </div>
    </div>

    <div class="modal-overlay promotion-modal" id="promotionModal">
        <div class="modal">
            <div class="promotion-title">Choose promotion piece</div>
            <div class="promotion-pieces" id="promotionPieces"></div>
        </div>
    </div>

    <script>
        const PIECE_IMAGES = {
            'K': 'https://raw.githubusercontent.com/corrodedfridge-tech/chess/main/whiteking.png',
            'Q': 'https://raw.githubusercontent.com/corrodedfridge-tech/chess/main/whitequeen.png',
            'R': 'https://raw.githubusercontent.com/corrodedfridge-tech/chess/main/whiterook.png',
            'B': 'https://raw.githubusercontent.com/corrodedfridge-tech/chess/main/whitebishop.png',
            'N': 'https://raw.githubusercontent.com/corrodedfridge-tech/chess/main/whiteknight.png',
            'P': 'https://raw.githubusercontent.com/corrodedfridge-tech/chess/main/whitepawn.png',
            'k': 'https://raw.githubusercontent.com/corrodedfridge-tech/chess/main/blackking.png',
            'q': 'https://raw.githubusercontent.com/corrodedfridge-tech/chess/main/blackqueen.png',
            'r': 'https://raw.githubusercontent.com/corrodedfridge-tech/chess/main/blackrook.png',
            'b': 'https://raw.githubusercontent.com/corrodedfridge-tech/chess/main/blackbishop.png',
            'n': 'https://raw.githubusercontent.com/corrodedfridge-tech/chess/main/blackknight.png',
            'p': 'https://raw.githubusercontent.com/corrodedfridge-tech/chess/main/blackpawn.png'
        };

        const CLASSIFICATION_ICONS = {
            brilliant: 'https://raw.githubusercontent.com/corrodedfridge-tech/chess/main/brilliantmove.png',
            great: 'https://raw.githubusercontent.com/corrodedfridge-tech/chess/main/greatmove.png',
            best: 'https://raw.githubusercontent.com/corrodedfridge-tech/chess/main/bestmove.png',
            good: 'https://raw.githubusercontent.com/corrodedfridge-tech/chess/main/goodmove.png',
            book: 'https://raw.githubusercontent.com/corrodedfridge-tech/chess/main/bookmove.png',
            inaccuracy: 'https://raw.githubusercontent.com/corrodedfridge-tech/chess/main/innacuracy.png',
            mistake: 'https://raw.githubusercontent.com/corrodedfridge-tech/chess/main/mistake.png',
            miss: 'https://raw.githubusercontent.com/corrodedfridge-tech/chess/main/miss.png',
            blunder: 'https://raw.githubusercontent.com/corrodedfridge-tech/chess/main/blunder.png',
            excellent: 'https://raw.githubusercontent.com/corrodedfridge-tech/chess/main/goodmove.png'
        };

        const ELO_DESCRIPTIONS = {
            0: "Tries to lose",
            100: "Absolute beginner",
            200: "Terrible",
            300: "Very weak",
            400: "Weak",
            500: "Novice",
            600: "Casual",
            700: "Learner",
            800: "Beginner",
            900: "Below average",
            1000: "Average",
            1100: "Improving",
            1200: "Decent",
            1300: "Competent",
            1400: "Solid",
            1500: "Intermediate",
            1600: "Good",
            1700: "Strong",
            1800: "Very strong",
            1900: "Expert",
            2000: "Candidate Master",
            2100: "Master",
            2200: "National Master",
            2300: "FIDE Master",
            2400: "International Master",
            2500: "Grandmaster",
            2600: "Super GM",
            2700: "Elite",
            2800: "World Class",
            2900: "Near Perfect",
            3000: "Engine Level",
            3100: "Superhuman",
            3200: "Unbeatable"
        };

        let audioCtx = null;
        function getAudioContext() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            return audioCtx;
        }

        function playSound(type) {
            try {
                const ctx = getAudioContext();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);
                
                switch(type) {
                    case 'move':
                        osc.frequency.value = 440;
                        osc.type = 'sine';
                        gain.gain.setValueAtTime(0.12, ctx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.08);
                        osc.start(); osc.stop(ctx.currentTime + 0.1);
                        break;
                    case 'capture':
                        osc.frequency.value = 220;
                        osc.type = 'triangle';
                        gain.gain.setValueAtTime(0.2, ctx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.15);
                        osc.start(); osc.stop(ctx.currentTime + 0.2);
                        break;
                    case 'check':
                        osc.frequency.value = 800;
                        osc.type = 'square';
                        gain.gain.setValueAtTime(0.08, ctx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.2);
                        osc.start(); osc.stop(ctx.currentTime + 0.25);
                        break;
                    case 'checkmate':
                        const notes = [523.25, 659.25, 783.99, 1046.50];
                        notes.forEach((freq, i) => {
                            const o = ctx.createOscillator();
                            const g = ctx.createGain();
                            o.connect(g); g.connect(ctx.destination);
                            o.frequency.value = freq;
                            o.type = 'sine';
                            g.gain.setValueAtTime(0, ctx.currentTime + i * 0.15);
                            g.gain.linearRampToValueAtTime(0.15, ctx.currentTime + i * 0.15 + 0.05);
                            g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + i * 0.15 + 0.4);
                            o.start(ctx.currentTime + i * 0.15);
                            o.stop(ctx.currentTime + i * 0.15 + 0.5);
                        });
                        return;
                    case 'defeat':
                        const low = [392, 349.23, 293.66, 261.63];
                        low.forEach((freq, i) => {
                            const o = ctx.createOscillator();
                            const g = ctx.createGain();
                            o.connect(g); g.connect(ctx.destination);
                            o.frequency.value = freq;
                            o.type = 'sine';
                            g.gain.setValueAtTime(0, ctx.currentTime + i * 0.2);
                            g.gain.linearRampToValueAtTime(0.12, ctx.currentTime + i * 0.2 + 0.05);
                            g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + i * 0.2 + 0.5);
                            o.start(ctx.currentTime + i * 0.2);
                            o.stop(ctx.currentTime + i * 0.2 + 0.6);
                        });
                        return;
                }
            } catch(e) {}
        }

        function createExplosion(x, y, count = 30) {
            const container = document.getElementById('particles');
            const colors = ['#ff6b6b', '#ffd93d', '#6bcb77', '#4d96ff', '#ff6bb5', '#fff'];
            
            for (let i = 0; i < count; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                const size = Math.random() * 12 + 4;
                const angle = (Math.PI * 2 * i) / count + Math.random() * 0.5;
                const distance = Math.random() * 150 + 80;
                const tx = Math.cos(angle) * distance;
                const ty = Math.sin(angle) * distance;
                
                particle.style.cssText = `
                    left: ${x}px; top: ${y}px;
                    width: ${size}px; height: ${size}px;
                    background: ${colors[Math.floor(Math.random() * colors.length)]};
                    --tx: ${tx}px; --ty: ${ty}px;
                `;
                container.appendChild(particle);
                setTimeout(() => particle.remove(), 1000);
            }
            
            for (let i = 0; i < 3; i++) {
                const ring = document.createElement('div');
                ring.className = 'explosion-ring';
                ring.style.cssText = `left: ${x - 20}px; top: ${y - 20}px; width: 40px; height: 40px;`;
                ring.style.animationDelay = `${i * 0.1}s`;
                container.appendChild(ring);
                setTimeout(() => ring.remove(), 600);
            }
        }

        function checkmateAnimation(kingSquare, playerWon) {
            const board = document.getElementById('board');
            const rect = board.getBoundingClientRect();
            const kingX = rect.left + kingSquare.col * 80 + 40;
            const kingY = rect.top + kingSquare.row * 80 + 40;
            
            const kingPiece = document.querySelector(`.square[data-row="${kingSquare.row}"][data-col="${kingSquare.col}"] .piece`);
            if (kingPiece) kingPiece.classList.add('king-fallen');
            
            document.getElementById('boardContainer').classList.add('shake');
            setTimeout(() => document.getElementById('boardContainer').classList.remove('shake'), 500);
            
            setTimeout(() => createExplosion(kingX, kingY, 40), 200);
            setTimeout(() => createExplosion(kingX - 30, kingY - 30, 20), 350);
            setTimeout(() => createExplosion(kingX + 30, kingY + 30, 20), 450);
            
            playSound(playerWon ? 'checkmate' : 'defeat');
        }

        // Chess Engine
        class ChessEngine {
            constructor() { this.reset(); }

            reset() {
                this.board = [
                    ['r','n','b','q','k','b','n','r'],
                    ['p','p','p','p','p','p','p','p'],
                    [null,null,null,null,null,null,null,null],
                    [null,null,null,null,null,null,null,null],
                    [null,null,null,null,null,null,null,null],
                    [null,null,null,null,null,null,null,null],
                    ['P','P','P','P','P','P','P','P'],
                    ['R','N','B','Q','K','B','N','R']
                ];
                this.turn = 'white';
                this.castling = { K: true, Q: true, k: true, q: true };
                this.enPassant = null;
                this.halfMoveClock = 0;
                this.fullMoveNumber = 1;
                this.moveHistory = [];
                this.capturedPieces = { white: [], black: [] };
            }

            clone() {
                const c = new ChessEngine();
                c.board = this.board.map(r => [...r]);
                c.turn = this.turn;
                c.castling = { ...this.castling };
                c.enPassant = this.enPassant ? { ...this.enPassant } : null;
                c.halfMoveClock = this.halfMoveClock;
                c.fullMoveNumber = this.fullMoveNumber;
                c.moveHistory = [...this.moveHistory];
                c.capturedPieces = { white: [...this.capturedPieces.white], black: [...this.capturedPieces.black] };
                return c;
            }

            isWhite(p) { return p && p === p.toUpperCase(); }
            getPieceColor(p) { return p ? (this.isWhite(p) ? 'white' : 'black') : null; }

            getKingPosition(color) {
                const k = color === 'white' ? 'K' : 'k';
                for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) if (this.board[r][c] === k) return { row: r, col: c };
                return null;
            }

            isSquareAttacked(row, col, byColor) {
                const pDir = byColor === 'white' ? 1 : -1;
                const pawn = byColor === 'white' ? 'P' : 'p';
                if (row + pDir >= 0 && row + pDir < 8) {
                    if (col > 0 && this.board[row + pDir][col - 1] === pawn) return true;
                    if (col < 7 && this.board[row + pDir][col + 1] === pawn) return true;
                }
                const knight = byColor === 'white' ? 'N' : 'n';
                for (const [dr, dc] of [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]]) {
                    const r = row + dr, c = col + dc;
                    if (r >= 0 && r < 8 && c >= 0 && c < 8 && this.board[r][c] === knight) return true;
                }
                const king = byColor === 'white' ? 'K' : 'k';
                for (let dr = -1; dr <= 1; dr++) for (let dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue;
                    const r = row + dr, c = col + dc;
                    if (r >= 0 && r < 8 && c >= 0 && c < 8 && this.board[r][c] === king) return true;
                }
                const dirs = [
                    { dr: -1, dc: 0, p: byColor === 'white' ? ['R','Q'] : ['r','q'] },
                    { dr: 1, dc: 0, p: byColor === 'white' ? ['R','Q'] : ['r','q'] },
                    { dr: 0, dc: -1, p: byColor === 'white' ? ['R','Q'] : ['r','q'] },
                    { dr: 0, dc: 1, p: byColor === 'white' ? ['R','Q'] : ['r','q'] },
                    { dr: -1, dc: -1, p: byColor === 'white' ? ['B','Q'] : ['b','q'] },
                    { dr: -1, dc: 1, p: byColor === 'white' ? ['B','Q'] : ['b','q'] },
                    { dr: 1, dc: -1, p: byColor === 'white' ? ['B','Q'] : ['b','q'] },
                    { dr: 1, dc: 1, p: byColor === 'white' ? ['B','Q'] : ['b','q'] }
                ];
                for (const { dr, dc, p } of dirs) {
                    let r = row + dr, c = col + dc;
                    while (r >= 0 && r < 8 && c >= 0 && c < 8) {
                        if (this.board[r][c]) { if (p.includes(this.board[r][c])) return true; break; }
                        r += dr; c += dc;
                    }
                }
                return false;
            }

            isInCheck(color) {
                const kp = this.getKingPosition(color);
                return kp ? this.isSquareAttacked(kp.row, kp.col, color === 'white' ? 'black' : 'white') : false;
            }

            generateLegalMoves(color = this.turn) {
                const moves = [];
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = this.board[r][c];
                        if (!piece || this.getPieceColor(piece) !== color) continue;
                        const pt = piece.toUpperCase();
                        
                        if (pt === 'P') {
                            const dir = color === 'white' ? -1 : 1;
                            const start = color === 'white' ? 6 : 1;
                            const promo = color === 'white' ? 0 : 7;
                            
                            if (r + dir >= 0 && r + dir < 8 && !this.board[r + dir][c]) {
                                if (r + dir === promo) ['Q','R','B','N'].forEach(p => moves.push({ from: {row:r,col:c}, to: {row:r+dir,col:c}, promotion: p }));
                                else moves.push({ from: {row:r,col:c}, to: {row:r+dir,col:c} });
                                
                                if (r === start && !this.board[r+2*dir][c]) moves.push({ from: {row:r,col:c}, to: {row:r+2*dir,col:c} });
                            }
                            
                            for (const dc of [-1, 1]) {
                                const nc = c + dc;
                                if (nc >= 0 && nc < 8 && r + dir >= 0 && r + dir < 8) {
                                    const target = this.board[r + dir][nc];
                                    const isEP = this.enPassant && this.enPassant.row === r + dir && this.enPassant.col === nc;
                                    if ((target && this.getPieceColor(target) !== color) || isEP) {
                                        if (r + dir === promo) ['Q','R','B','N'].forEach(p => moves.push({ from: {row:r,col:c}, to: {row:r+dir,col:nc}, promotion: p, isEnPassant: isEP }));
                                        else moves.push({ from: {row:r,col:c}, to: {row:r+dir,col:nc}, isEnPassant: isEP });
                                    }
                                }
                            }
                        }
                        
                        if (pt === 'N') {
                            for (const [dr, dc] of [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]]) {
                                const nr = r + dr, nc = c + dc;
                                if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8 && this.getPieceColor(this.board[nr][nc]) !== color)
                                    moves.push({ from: {row:r,col:c}, to: {row:nr,col:nc} });
                            }
                        }
                        
                        if (pt === 'B' || pt === 'Q') {
                            for (const [dr, dc] of [[-1,-1],[-1,1],[1,-1],[1,1]]) {
                                let nr = r + dr, nc = c + dc;
                                while (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                                    if (!this.board[nr][nc]) moves.push({ from: {row:r,col:c}, to: {row:nr,col:nc} });
                                    else { if (this.getPieceColor(this.board[nr][nc]) !== color) moves.push({ from: {row:r,col:c}, to: {row:nr,col:nc} }); break; }
                                    nr += dr; nc += dc;
                                }
                            }
                        }
                        
                        if (pt === 'R' || pt === 'Q') {
                            for (const [dr, dc] of [[-1,0],[1,0],[0,-1],[0,1]]) {
                                let nr = r + dr, nc = c + dc;
                                while (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                                    if (!this.board[nr][nc]) moves.push({ from: {row:r,col:c}, to: {row:nr,col:nc} });
                                    else { if (this.getPieceColor(this.board[nr][nc]) !== color) moves.push({ from: {row:r,col:c}, to: {row:nr,col:nc} }); break; }
                                    nr += dr; nc += dc;
                                }
                            }
                        }
                        
                        if (pt === 'K') {
                            for (let dr = -1; dr <= 1; dr++) for (let dc = -1; dc <= 1; dc++) {
                                if (dr === 0 && dc === 0) continue;
                                const nr = r + dr, nc = c + dc;
                                if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8 && this.getPieceColor(this.board[nr][nc]) !== color)
                                    moves.push({ from: {row:r,col:c}, to: {row:nr,col:nc} });
                            }
                            const row = color === 'white' ? 7 : 0;
                            if (r === row && c === 4 && !this.isInCheck(color)) {
                                const ks = color === 'white' ? 'K' : 'k', qs = color === 'white' ? 'Q' : 'q';
                                const opp = color === 'white' ? 'black' : 'white';
                                if (this.castling[ks] && !this.board[row][5] && !this.board[row][6] &&
                                    !this.isSquareAttacked(row, 5, opp) && !this.isSquareAttacked(row, 6, opp))
                                    moves.push({ from: {row:r,col:c}, to: {row:row,col:6}, isCastling: 'kingside' });
                                if (this.castling[qs] && !this.board[row][3] && !this.board[row][2] && !this.board[row][1] &&
                                    !this.isSquareAttacked(row, 3, opp) && !this.isSquareAttacked(row, 2, opp))
                                    moves.push({ from: {row:r,col:c}, to: {row:row,col:2}, isCastling: 'queenside' });
                            }
                        }
                    }
                }
                
                return moves.filter(m => {
                    const c = this.clone();
                    c.makeMove(m, true);
                    return !c.isInCheck(color);
                });
            }

            makeMove(move, skip = false) {
                const { from, to, promotion, isEnPassant, isCastling } = move;
                const piece = this.board[from.row][from.col];
                const captured = this.board[to.row][to.col];
                const color = this.getPieceColor(piece);

                if (captured) this.capturedPieces[color].push(captured);
                if (isEnPassant) {
                    const cr = color === 'white' ? to.row + 1 : to.row - 1;
                    this.capturedPieces[color].push(this.board[cr][to.col]);
                    this.board[cr][to.col] = null;
                }

                this.board[to.row][to.col] = promotion ? (color === 'white' ? promotion : promotion.toLowerCase()) : piece;
                this.board[from.row][from.col] = null;

                if (isCastling) {
                    const row = from.row;
                    if (isCastling === 'kingside') { this.board[row][5] = this.board[row][7]; this.board[row][7] = null; }
                    else { this.board[row][3] = this.board[row][0]; this.board[row][0] = null; }
                }

                if (piece.toUpperCase() === 'K') {
                    if (color === 'white') { this.castling.K = false; this.castling.Q = false; }
                    else { this.castling.k = false; this.castling.q = false; }
                }
                if (piece.toUpperCase() === 'R') {
                    if (from.row === 7 && from.col === 7) this.castling.K = false;
                    if (from.row === 7 && from.col === 0) this.castling.Q = false;
                    if (from.row === 0 && from.col === 7) this.castling.k = false;
                    if (from.row === 0 && from.col === 0) this.castling.q = false;
                }

                this.enPassant = (piece.toUpperCase() === 'P' && Math.abs(to.row - from.row) === 2) ?
                    { row: (from.row + to.row) / 2, col: from.col } : null;

                this.halfMoveClock = (captured || piece.toUpperCase() === 'P') ? 0 : this.halfMoveClock + 1;
                if (color === 'black') this.fullMoveNumber++;

                if (!skip) {
                    const notation = this.getMoveNotation(move, piece, captured, isCastling);
                    this.moveHistory.push({ ...move, notation, piece, captured, boardState: this.getBoardState() });
                }

                this.turn = this.turn === 'white' ? 'black' : 'white';
                return { captured, isEnPassant, isCastling };
            }

            getMoveNotation(move, piece, captured, isCastling) {
                if (isCastling === 'kingside') return 'O-O';
                if (isCastling === 'queenside') return 'O-O-O';
                const files = 'abcdefgh';
                const pt = piece.toUpperCase();
                let n = pt !== 'P' ? pt : '';
                if (captured || move.isEnPassant) { if (pt === 'P') n += files[move.from.col]; n += 'x'; }
                n += files[move.to.col] + (8 - move.to.row);
                if (move.promotion) n += '=' + move.promotion;
                const copy = this.clone();
                const opp = this.getPieceColor(piece) === 'white' ? 'black' : 'white';
                if (copy.isInCheck(opp)) n += copy.generateLegalMoves(opp).length === 0 ? '#' : '+';
                return n;
            }

            getBoardState() {
                return { board: this.board.map(r => [...r]), turn: this.turn, castling: { ...this.castling }, enPassant: this.enPassant ? { ...this.enPassant } : null };
            }

            isCheckmate() { return this.isInCheck(this.turn) && this.generateLegalMoves().length === 0; }
            isStalemate() { return !this.isInCheck(this.turn) && this.generateLegalMoves().length === 0; }
            isDraw() {
                if (this.isStalemate()) return 'stalemate';
                if (this.halfMoveClock >= 100) return 'fifty-move';
                const pieces = this.board.flat().filter(p => p);
                if (pieces.length === 2) return 'insufficient';
                if (pieces.length === 3 && pieces.some(p => ['N','n','B','b'].includes(p))) return 'insufficient';
                return false;
            }

            evaluate() {
                const vals = { P: 100, N: 320, B: 330, R: 500, Q: 900, K: 20000 };
                const tables = {
                    P: [[0,0,0,0,0,0,0,0],[50,50,50,50,50,50,50,50],[10,10,20,30,30,20,10,10],[5,5,10,25,25,10,5,5],[0,0,0,20,20,0,0,0],[5,-5,-10,0,0,-10,-5,5],[5,10,10,-20,-20,10,10,5],[0,0,0,0,0,0,0,0]],
                    N: [[-50,-40,-30,-30,-30,-30,-40,-50],[-40,-20,0,0,0,0,-20,-40],[-30,0,10,15,15,10,0,-30],[-30,5,15,20,20,15,5,-30],[-30,0,15,20,20,15,0,-30],[-30,5,10,15,15,10,5,-30],[-40,-20,0,5,5,0,-20,-40],[-50,-40,-30,-30,-30,-30,-40,-50]],
                    B: [[-20,-10,-10,-10,-10,-10,-10,-20],[-10,0,0,0,0,0,0,-10],[-10,0,5,10,10,5,0,-10],[-10,5,5,10,10,5,5,-10],[-10,0,10,10,10,10,0,-10],[-10,10,10,10,10,10,10,-10],[-10,5,0,0,0,0,5,-10],[-20,-10,-10,-10,-10,-10,-10,-20]],
                    R: [[0,0,0,0,0,0,0,0],[5,10,10,10,10,10,10,5],[-5,0,0,0,0,0,0,-5],[-5,0,0,0,0,0,0,-5],[-5,0,0,0,0,0,0,-5],[-5,0,0,0,0,0,0,-5],[-5,0,0,0,0,0,0,-5],[0,0,0,5,5,0,0,0]],
                    Q: [[-20,-10,-10,-5,-5,-10,-10,-20],[-10,0,0,0,0,0,0,-10],[-10,0,5,5,5,5,0,-10],[-5,0,5,5,5,5,0,-5],[0,0,5,5,5,5,0,-5],[-10,5,5,5,5,5,0,-10],[-10,0,5,0,0,0,0,-10],[-20,-10,-10,-5,-5,-10,-10,-20]],
                    K: [[-30,-40,-40,-50,-50,-40,-40,-30],[-30,-40,-40,-50,-50,-40,-40,-30],[-30,-40,-40,-50,-50,-40,-40,-30],[-30,-40,-40,-50,-50,-40,-40,-30],[-20,-30,-30,-40,-40,-30,-30,-20],[-10,-20,-20,-20,-20,-20,-20,-10],[20,20,0,0,0,0,20,20],[20,30,10,0,0,10,30,20]]
                };
                let score = 0;
                for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) {
                    const p = this.board[r][c]; if (!p) continue;
                    const isW = this.isWhite(p), pt = p.toUpperCase();
                    const val = vals[pt] || 0, tbl = tables[pt], tv = tbl ? (isW ? tbl[r][c] : tbl[7-r][c]) : 0;
                    score += isW ? (val + tv) : -(val + tv);
                }
                return score;
            }
        }

        // AI
        class ChessAI {
            constructor(elo = 1500) {
                this.setElo(elo);
            }

            setElo(elo) {
                this.elo = elo;
                this.tryToLose = elo === 0;
                
                if (elo === 0) { this.depth = 3; this.randomness = 0; }
                else if (elo <= 400) { this.depth = 1; this.randomness = 300; }
                else if (elo <= 800) { this.depth = 1; this.randomness = 150; }
                else if (elo <= 1200) { this.depth = 2; this.randomness = 100; }
                else if (elo <= 1600) { this.depth = 3; this.randomness = 50; }
                else if (elo <= 2000) { this.depth = 4; this.randomness = 20; }
                else if (elo <= 2400) { this.depth = 4; this.randomness = 5; }
                else if (elo <= 2800) { this.depth = 5; this.randomness = 0; }
                else { this.depth = 6; this.randomness = 0; }
            }

            getBestMove(engine) {
                const moves = engine.generateLegalMoves();
                if (!moves.length) return null;
                
                if (this.elo <= 400 && this.elo > 0) {
                    const randomIndex = Math.floor(Math.random() * moves.length);
                    if (Math.random() < 0.5) return { move: moves[randomIndex], score: 0 };
                }

                let best = null;
                let bestScore = this.tryToLose ? Infinity : (engine.turn === 'white' ? -Infinity : Infinity);
                
                const scoredMoves = [];
                
                for (const m of moves) {
                    const c = engine.clone();
                    c.makeMove(m, true);
                    let s = this.minimax(c, this.depth - 1, -Infinity, Infinity, engine.turn !== 'white');
                    s += (Math.random() - 0.5) * this.randomness;
                    scoredMoves.push({ move: m, score: s });
                }
                
                scoredMoves.sort((a, b) => {
                    if (this.tryToLose) {
                        return engine.turn === 'white' ? a.score - b.score : b.score - a.score;
                    }
                    return engine.turn === 'white' ? b.score - a.score : a.score - b.score;
                });
                
                return scoredMoves[0];
            }

            minimax(e, d, a, b, max) {
                if (d === 0) return e.evaluate();
                const moves = e.generateLegalMoves();
                if (!moves.length) return e.isInCheck(e.turn) ? (max ? -99999 : 99999) : 0;
                
                if (max) {
                    let v = -Infinity;
                    for (const m of moves) {
                        const c = e.clone(); c.makeMove(m, true);
                        v = Math.max(v, this.minimax(c, d-1, a, b, false));
                        a = Math.max(a, v);
                        if (b <= a) break;
                    }
                    return v;
                } else {
                    let v = Infinity;
                    for (const m of moves) {
                        const c = e.clone(); c.makeMove(m, true);
                        v = Math.min(v, this.minimax(c, d-1, a, b, true));
                        b = Math.min(b, v);
                        if (b <= a) break;
                    }
                    return v;
                }
            }

            analyzeMove(eng, move, color) {
                const oldDepth = this.depth;
                const oldRand = this.randomness;
                const oldLose = this.tryToLose;
                
                this.depth = 4;
                this.randomness = 0;
                this.tryToLose = false;
                
                const best = this.getBestMove(eng);
                
                this.depth = oldDepth;
                this.randomness = oldRand;
                this.tryToLose = oldLose;
                
                if (!best?.move) return { classification: 'book', evalChange: 0, evalAfter: 0 };
                
                const afterBest = eng.clone(); afterBest.makeMove(best.move, true);
                const after = eng.clone(); after.makeMove(move, true);
                const evalBest = afterBest.evaluate() * (color === 'white' ? 1 : -1);
                const evalActual = after.evaluate() * (color === 'white' ? 1 : -1);
                const change = (evalActual - evalBest) / 100;
                const isBest = move.from.row === best.move.from.row && move.from.col === best.move.from.col &&
                               move.to.row === best.move.to.row && move.to.col === best.move.to.col;
                
                let cls;
                if (isBest) cls = 'best';
                else if (change >= -0.1) cls = 'excellent';
                else if (change >= -0.25) cls = 'good';
                else if (change >= -0.6) cls = 'inaccuracy';
                else if (change >= -1.5) cls = 'mistake';
                else cls = 'blunder';

                const piece = eng.board[move.from.row][move.from.col];
                const vals = { P:1, N:3, B:3, R:5, Q:9, K:0 };
                const pv = vals[piece?.toUpperCase()] || 0;
                const opp = color === 'white' ? 'black' : 'white';
                if (eng.isSquareAttacked(move.to.row, move.to.col, opp) && !isBest && change >= 1) {
                    const cap = eng.board[move.to.row][move.to.col];
                    const cv = cap ? vals[cap.toUpperCase()] : 0;
                    if (pv > cv && change >= 2) cls = 'brilliant';
                }
                if (cls === 'best' && !eng.board[move.to.row][move.to.col] && !move.isCastling) cls = 'great';

                return { classification: cls, evalChange: change, evalAfter: evalActual / 100, bestMove: best.move, isBestMove: isBest };
            }
        }

        // State
        let engine = new ChessEngine();
        let ai = new ChessAI(1500);
        let selectedSquare = null;
        let legalMoves = [];
        let gameOver = false;
        let reviewMode = false;
        let reviewMoveIndex = -1;
        let moveAnalysis = [];
        let dragging = false;
        let dragStartSquare = null;
        let ghostPiece = null;

        function init() {
            renderBoard();
            updateMoveList();
            updateEvalBar(0);
            
            const slider = document.getElementById('eloSlider');
            slider.addEventListener('input', e => {
                const elo = parseInt(e.target.value);
                ai.setElo(elo);
                document.getElementById('eloDisplay').textContent = elo;
                document.getElementById('eloDesc').textContent = ELO_DESCRIPTIONS[elo] || 'Custom';
                document.getElementById('botRating').textContent = `ELO ${elo}`;
                
                let name = 'Chess Bot';
                if (elo === 0) name = 'Drunk Bot ðŸº';
                else if (elo <= 400) name = 'Baby Bot ðŸ‘¶';
                else if (elo <= 800) name = 'Beginner Bot';
                else if (elo <= 1200) name = 'Casual Bot';
                else if (elo <= 1600) name = 'Intermediate Bot';
                else if (elo <= 2000) name = 'Expert Bot';
                else if (elo <= 2400) name = 'Master Bot';
                else if (elo <= 2800) name = 'Grandmaster Bot';
                else name = 'Stockfish ðŸŸ';
                document.getElementById('botName').textContent = name;
            });
            
            document.addEventListener('keydown', e => {
                if (e.key === 'ArrowLeft') goBack();
                if (e.key === 'ArrowRight') goForward();
                if (e.key === 'ArrowUp') { e.preventDefault(); goToStart(); }
                if (e.key === 'ArrowDown') { e.preventDefault(); goToEnd(); }
            });
        }

        function renderBoard(customState = null, showClassification = false, classIndex = -1) {
            const board = document.getElementById('board');
            board.innerHTML = '';
            const state = customState || engine.board;
            const files = 'abcdefgh';

            let lastMove = null;
            let classification = null;
            if (reviewMode && classIndex >= 0 && engine.moveHistory[classIndex]) {
                lastMove = engine.moveHistory[classIndex];
                classification = moveAnalysis[classIndex];
            } else if (!customState && engine.moveHistory.length > 0) {
                lastMove = engine.moveHistory[engine.moveHistory.length - 1];
            }

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const sq = document.createElement('div');
                    const isLight = (r + c) % 2 === 0;
                    sq.className = `square ${isLight ? 'light' : 'dark'}`;
                    sq.dataset.row = r;
                    sq.dataset.col = c;

                    if (lastMove && ((lastMove.from.row === r && lastMove.from.col === c) || (lastMove.to.row === r && lastMove.to.col === c))) {
                        sq.classList.add('last-move');
                    }
                    if (selectedSquare?.row === r && selectedSquare?.col === c) sq.classList.add('selected');
                    if (legalMoves.some(m => m.to.row === r && m.to.col === c)) {
                        sq.classList.add(state[r][c] ? 'legal-capture' : 'legal-move');
                    }
                    if (!customState && engine.isInCheck(engine.turn)) {
                        const kp = engine.getKingPosition(engine.turn);
                        if (kp?.row === r && kp?.col === c) sq.classList.add('check');
                    }

                    if (c === 0) { const rank = document.createElement('span'); rank.className = 'coordinate rank'; rank.textContent = 8 - r; sq.appendChild(rank); }
                    if (r === 7) { const file = document.createElement('span'); file.className = 'coordinate file'; file.textContent = files[c]; sq.appendChild(file); }

                    const piece = state[r][c];
                    if (piece && !(dragging && dragStartSquare?.row === r && dragStartSquare?.col === c)) {
                        const img = document.createElement('img');
                        img.src = PIECE_IMAGES[piece];
                        img.className = 'piece';
                        img.draggable = false;
                        img.addEventListener('mousedown', e => startDrag(e, r, c, piece));
                        sq.appendChild(img);
                    }

                    if (showClassification && classification && lastMove?.to.row === r && lastMove?.to.col === c) {
                        const icon = document.createElement('img');
                        icon.src = CLASSIFICATION_ICONS[classification.classification];
                        icon.className = 'move-classification-icon';
                        sq.appendChild(icon);
                    }

                    sq.addEventListener('click', () => handleClick(r, c));
                    sq.addEventListener('mouseup', e => endDrag(e, r, c));
                    board.appendChild(sq);
                }
            }
            updateCapturedPieces();
            updatePlayerIndicators();
        }

        function startDrag(e, r, c, piece) {
            if (gameOver || reviewMode || engine.turn !== 'white' || !engine.isWhite(piece)) return;
            e.preventDefault();
            dragging = true;
            dragStartSquare = { row: r, col: c };
            selectedSquare = { row: r, col: c };
            legalMoves = engine.generateLegalMoves().filter(m => m.from.row === r && m.from.col === c);
            
            ghostPiece = document.createElement('img');
            ghostPiece.src = PIECE_IMAGES[piece];
            ghostPiece.className = 'ghost-piece';
            document.body.appendChild(ghostPiece);
            moveGhost(e);
            renderBoard();
            
            document.addEventListener('mousemove', moveGhost);
            document.addEventListener('mouseup', dropPiece);
        }

        function moveGhost(e) { if (ghostPiece) { ghostPiece.style.left = e.clientX + 'px'; ghostPiece.style.top = e.clientY + 'px'; } }
        function dropPiece() {
            document.removeEventListener('mousemove', moveGhost);
            document.removeEventListener('mouseup', dropPiece);
            if (ghostPiece) { ghostPiece.remove(); ghostPiece = null; }
            dragging = false; dragStartSquare = null;
        }

        function endDrag(e, r, c) {
            if (!dragging) return;
            const move = legalMoves.find(m => m.to.row === r && m.to.col === c);
            if (move) {
                if (move.promotion) { showPromotion(move); return; }
                makePlayerMove(move);
            }
            selectedSquare = null; legalMoves = []; dragging = false; dragStartSquare = null;
            if (ghostPiece) { ghostPiece.remove(); ghostPiece = null; }
            renderBoard();
        }

        function handleClick(r, c) {
            if (gameOver || reviewMode || dragging || engine.turn !== 'white') return;
            const move = legalMoves.find(m => m.to.row === r && m.to.col === c);
            if (move) { if (move.promotion) { showPromotion(move); return; } makePlayerMove(move); return; }
            const piece = engine.board[r][c];
            if (piece && engine.isWhite(piece)) {
                selectedSquare = { row: r, col: c };
                legalMoves = engine.generateLegalMoves().filter(m => m.from.row === r && m.from.col === c);
            } else { selectedSquare = null; legalMoves = []; }
            renderBoard();
        }

        function showPromotion(move) {
            const modal = document.getElementById('promotionModal');
            const container = document.getElementById('promotionPieces');
            container.innerHTML = '';
            ['Q','R','B','N'].forEach(p => {
                const div = document.createElement('div');
                div.className = 'promotion-piece';
                const img = document.createElement('img');
                img.src = PIECE_IMAGES[p];
                div.appendChild(img);
                div.onclick = () => { modal.classList.remove('active'); selectedSquare = null; legalMoves = []; makePlayerMove({ ...move, promotion: p }); };
                container.appendChild(div);
            });
            modal.classList.add('active');
        }

        function makePlayerMove(move) {
            const captured = engine.board[move.to.row][move.to.col];
            const result = engine.makeMove(move);
            selectedSquare = null; legalMoves = [];
            
            if (result.isCastling) playSound('move');
            else if (captured || result.isEnPassant) { playSound('capture'); flashSquare(move.to.row, move.to.col); }
            else if (move.promotion) playSound('move');
            else playSound('move');

            renderBoard();
            updateMoveList();
            updateEvalBar(engine.evaluate() / 100);

            if (engine.isInCheck(engine.turn)) playSound('check');
            if (checkGameEnd()) return;
            setTimeout(makeAIMove, 400);
        }

        function flashSquare(r, c) {
            setTimeout(() => {
                const sq = document.querySelector(`.square[data-row="${r}"][data-col="${c}"]`);
                if (sq) sq.classList.add('capture-flash');
            }, 50);
        }

        function makeAIMove() {
            if (gameOver) return;
            document.getElementById('thinkingIndicator').style.display = 'flex';
            
            const thinkTime = Math.max(200, Math.min(1500, ai.elo / 2));
            
            setTimeout(() => {
                const result = ai.getBestMove(engine);
                document.getElementById('thinkingIndicator').style.display = 'none';
                if (result?.move) {
                    const captured = engine.board[result.move.to.row][result.move.to.col];
                    const moveResult = engine.makeMove(result.move);
                    
                    if (captured || moveResult.isEnPassant) { playSound('capture'); flashSquare(result.move.to.row, result.move.to.col); }
                    else playSound('move');

                    renderBoard();
                    updateMoveList();
                    updateEvalBar(engine.evaluate() / 100);
                    if (engine.isInCheck(engine.turn)) { playSound('check'); document.getElementById('boardContainer').classList.add('shake'); setTimeout(() => document.getElementById('boardContainer').classList.remove('shake'), 400); }
                    checkGameEnd();
                }
            }, thinkTime);
        }

        function checkGameEnd() {
            if (engine.isCheckmate()) {
                gameOver = true;
                const playerWon = engine.turn === 'black';
                const kingPos = engine.getKingPosition(engine.turn);
                
                setTimeout(() => checkmateAnimation(kingPos, playerWon), 100);
                
                setTimeout(() => {
                    const icon = document.getElementById('gameOverIcon');
                    const title = document.getElementById('gameOverTitle');
                    const msg = document.getElementById('gameOverMessage');
                    
                    if (playerWon) {
                        icon.textContent = 'ðŸ‘‘';
                        icon.classList.add('victory');
                        title.textContent = 'Victory!';
                        msg.textContent = 'You won by checkmate!';
                    } else {
                        icon.textContent = 'ðŸ’€';
                        icon.classList.remove('victory');
                        title.textContent = 'Defeat';
                        msg.textContent = 'You were checkmated.';
                    }
                    
                    document.getElementById('gameStatus').textContent = playerWon ? 'You won!' : 'You lost';
                    document.getElementById('gameOverModal').classList.add('active');
                }, 1200);
                
                return true;
            }
            
            const draw = engine.isDraw();
            if (draw) {
                gameOver = true;
                document.getElementById('gameOverIcon').textContent = 'ðŸ¤';
                document.getElementById('gameOverIcon').classList.remove('victory');
                document.getElementById('gameOverTitle').textContent = 'Draw';
                document.getElementById('gameOverMessage').textContent = draw === 'stalemate' ? 'Stalemate' : draw === 'fifty-move' ? 'Fifty-move rule' : 'Insufficient material';
                document.getElementById('gameStatus').textContent = 'Draw';
                document.getElementById('gameOverModal').classList.add('active');
                return true;
            }
            return false;
        }

        function closeModal() { document.querySelectorAll('.modal-overlay').forEach(m => m.classList.remove('active')); }

        function resign() {
            if (gameOver || !engine.moveHistory.length) return;
            gameOver = true;
            playSound('defeat');
            document.getElementById('gameOverIcon').textContent = 'ðŸ³ï¸';
            document.getElementById('gameOverTitle').textContent = 'You Resigned';
            document.getElementById('gameOverMessage').textContent = 'Black wins';
            document.getElementById('gameStatus').textContent = 'You resigned';
            document.getElementById('gameOverModal').classList.add('active');
        }

        function updateMoveList() {
            const container = document.getElementById('movesContainer');
            const moves = engine.moveHistory;
            if (!moves.length) {
                container.innerHTML = '<div class="empty-state"><div class="empty-state-icon">â™Ÿ</div><div class="empty-state-text">No moves yet.<br>Make your first move!</div></div>';
                return;
            }
            container.innerHTML = '';
            for (let i = 0; i < moves.length; i += 2) {
                const row = document.createElement('div');
                row.className = 'move-row';
                row.innerHTML = `<span class="move-number">${i/2+1}.</span>`;
                
                const wm = document.createElement('span');
                wm.className = 'move' + (reviewMode && reviewMoveIndex === i ? ' current' : '');
                if (moveAnalysis[i]) { const icon = document.createElement('img'); icon.src = CLASSIFICATION_ICONS[moveAnalysis[i].classification]; icon.className = 'move-icon'; wm.appendChild(icon); }
                wm.appendChild(document.createTextNode(moves[i].notation));
                wm.onclick = () => goToMove(i);
                row.appendChild(wm);
                
                if (moves[i+1]) {
                    const bm = document.createElement('span');
                    bm.className = 'move' + (reviewMode && reviewMoveIndex === i+1 ? ' current' : '');
                    if (moveAnalysis[i+1]) { const icon = document.createElement('img'); icon.src = CLASSIFICATION_ICONS[moveAnalysis[i+1].classification]; icon.className = 'move-icon'; bm.appendChild(icon); }
                    bm.appendChild(document.createTextNode(moves[i+1].notation));
                    bm.onclick = () => goToMove(i+1);
                    row.appendChild(bm);
                }
                container.appendChild(row);
            }
            container.scrollTop = container.scrollHeight;
        }

        function updateEvalBar(ev) {
            const bar = document.getElementById('evalBar');
            const tw = document.getElementById('evalTextWhite');
            const tb = document.getElementById('evalTextBlack');
            const clamped = Math.max(-10, Math.min(10, ev));
            bar.style.height = (50 + (clamped / 10) * 50) + '%';
            if (ev > 0) { tw.textContent = '+' + ev.toFixed(1); tb.textContent = ''; }
            else if (ev < 0) { tw.textContent = ''; tb.textContent = Math.abs(ev).toFixed(1); }
            else { tw.textContent = '0.0'; tb.textContent = ''; }
        }

        function updateCapturedPieces() {
            const order = { q:0, r:1, b:2, n:3, p:4, Q:0, R:1, B:2, N:3, P:4 };
            const vals = { P:1, N:3, B:3, R:5, Q:9, p:1, n:3, b:3, r:5, q:9 };
            let wMat = 0, bMat = 0;
            engine.capturedPieces.white.forEach(p => wMat += vals[p] || 0);
            engine.capturedPieces.black.forEach(p => bMat += vals[p] || 0);
            const adv = wMat - bMat;

            const wCont = document.getElementById('capturedWhite');
            const wCap = [...engine.capturedPieces.white].sort((a,b) => order[a] - order[b]);
            wCont.innerHTML = wCap.map(p => `<img src="${PIECE_IMAGES[p]}" class="captured-piece">`).join('');
            if (adv > 0) wCont.innerHTML += `<span class="material-advantage">+${adv}</span>`;

            const bCont = document.getElementById('capturedBlack');
            const bCap = [...engine.capturedPieces.black].sort((a,b) => order[a] - order[b]);
            bCont.innerHTML = bCap.map(p => `<img src="${PIECE_IMAGES[p]}" class="captured-piece">`).join('');
            if (adv < 0) bCont.innerHTML += `<span class="material-advantage">+${Math.abs(adv)}</span>`;
        }

        function updatePlayerIndicators() {
            document.getElementById('whitePlayer').classList.toggle('active', engine.turn === 'white' && !gameOver);
            document.getElementById('blackPlayer').classList.toggle('active', engine.turn === 'black' && !gameOver);
            document.getElementById('whiteClock').classList.toggle('active', engine.turn === 'white' && !gameOver);
            document.getElementById('blackClock').classList.toggle('active', engine.turn === 'black' && !gameOver);
        }

        function newGame() {
            engine = new ChessEngine();
            gameOver = false;
            reviewMode = false;
            selectedSquare = null;
            legalMoves = [];
            moveAnalysis = [];
            reviewMoveIndex = -1;
            closeModal();
            renderBoard();
            updateMoveList();
            updateEvalBar(0);
            document.getElementById('gameStatus').textContent = '';
            showPanelTab('moves');
            document.getElementById('playTab').classList.add('active');
            document.getElementById('reviewTabBtn').classList.remove('active');
        }

        function showGame() {
            document.getElementById('playTab').classList.add('active');
            document.getElementById('reviewTabBtn').classList.remove('active');
            reviewMode = false;
            reviewMoveIndex = -1;
            renderBoard();
            updateMoveList();
        }

        function showPanelTab(tab) {
            document.querySelectorAll('.tab').forEach((t,i) => t.classList.toggle('active', (tab === 'moves' && i === 0) || (tab === 'review' && i === 1)));
            document.getElementById('movesPanel').style.display = tab === 'moves' ? 'flex' : 'none';
            document.getElementById('reviewPanel').style.display = tab === 'review' ? 'block' : 'none';
            document.getElementById('reviewPanel').classList.toggle('active', tab === 'review');
        }

        function startReview() {
            if (!engine.moveHistory.length) { alert('Play a game first!'); return; }
            document.getElementById('playTab').classList.remove('active');
            document.getElementById('reviewTabBtn').classList.add('active');
            showPanelTab('review');
            document.getElementById('reviewContent').innerHTML = '<div class="analyzing-container"><div class="spinner"></div><div class="analyzing-text">Analyzing your game...</div><div class="analyzing-subtext">This may take a moment</div></div>';
            setTimeout(analyzeGame, 100);
        }

        function analyzeGame() {
            moveAnalysis = [];
            const temp = new ChessEngine();
            const analyzer = new ChessAI(2800);
            
            for (let i = 0; i < engine.moveHistory.length; i++) {
                const move = engine.moveHistory[i];
                const color = i % 2 === 0 ? 'white' : 'black';
                const analysis = analyzer.analyzeMove(temp, move, color);
                moveAnalysis.push(analysis);
                temp.makeMove(move, true);
            }
            
            showReviewResults();
            reviewMode = true;
            reviewMoveIndex = -1;
            updateMoveList();
        }

        function showReviewResults() {
            const content = document.getElementById('reviewContent');
            const wA = moveAnalysis.filter((_,i) => i % 2 === 0);
            const bA = moveAnalysis.filter((_,i) => i % 2 === 1);
            
            const calcAcc = arr => {
                if (!arr.length) return 100;
                return Math.round(arr.reduce((s,a) => s + ({brilliant:100,great:100,best:100,excellent:95,good:87,book:92,inaccuracy:52,mistake:26,miss:15,blunder:0}[a.classification] || 80), 0) / arr.length);
            };
            const wAcc = calcAcc(wA), bAcc = calcAcc(bA);
            const cnt = (arr, cls) => arr.filter(a => a.classification === cls).length;
            const circ = 2 * Math.PI * 46;
            
            const classes = [
                { key: 'brilliant', name: 'Brilliant' },
                { key: 'great', name: 'Great Move' },
                { key: 'best', name: 'Best Move' },
                { key: 'excellent', name: 'Excellent' },
                { key: 'good', name: 'Good' },
                { key: 'book', name: 'Book' },
                { key: 'inaccuracy', name: 'Inaccuracy' },
                { key: 'mistake', name: 'Mistake' },
                { key: 'blunder', name: 'Blunder' }
            ];

            content.innerHTML = `
                <div class="accuracy-section">
                    <div class="accuracy-row">
                        <div class="accuracy-item">
                            <div class="accuracy-ring white">
                                <svg viewBox="0 0 100 100"><circle class="bg" cx="50" cy="50" r="46"/><circle class="progress" cx="50" cy="50" r="46" stroke-dasharray="${circ}" stroke-dashoffset="${circ * (1 - wAcc/100)}"/></svg>
                                <div class="accuracy-value">${wAcc}<span class="accuracy-percent">%</span></div>
                            </div>
                            <div class="accuracy-label">Your Accuracy</div>
                        </div>
                        <div class="accuracy-item">
                            <div class="accuracy-ring black">
                                <svg viewBox="0 0 100 100"><circle class="bg" cx="50" cy="50" r="46"/><circle class="progress" cx="50" cy="50" r="46" stroke-dasharray="${circ}" stroke-dashoffset="${circ * (1 - bAcc/100)}"/></svg>
                                <div class="accuracy-value">${bAcc}<span class="accuracy-percent">%</span></div>
                            </div>
                            <div class="accuracy-label">Bot Accuracy</div>
                        </div>
                    </div>
                </div>
                <div class="classification-section">
                    <div class="classification-header"><span>White</span><span>Black</span></div>
                    ${classes.map(c => `
                        <div class="classification-row">
                            <div class="classification-label">
                                <img src="${CLASSIFICATION_ICONS[c.key]}" class="classification-icon">
                                <span class="classification-name">${c.name}</span>
                            </div>
                            <div class="classification-counts">
                                <span class="count-badge ${cnt(wA,c.key) > 0 ? 'has-value' : ''}">${cnt(wA,c.key)}</span>
                                <span class="count-badge ${cnt(bA,c.key) > 0 ? 'has-value' : ''}">${cnt(bA,c.key)}</span>
                            </div>
                        </div>
                    `).join('')}
                </div>
                <div id="reviewMoveInfo"></div>
            `;
        }

        function goToMove(idx) {
            if (idx < -1 || idx >= engine.moveHistory.length) return;
            reviewMoveIndex = idx;
            
            if (idx === -1) {
                renderBoard(new ChessEngine().board, false, -1);
                updateEvalBar(0);
            } else {
                const state = engine.moveHistory[idx].boardState;
                renderBoard(state.board, true, idx);
                if (moveAnalysis[idx]) {
                    updateEvalBar(moveAnalysis[idx].evalAfter);
                    showMoveInfo(idx);
                }
            }
            updateMoveList();
        }

        function showMoveInfo(idx) {
            const info = document.getElementById('reviewMoveInfo');
            if (!info || !moveAnalysis[idx]) return;
            const a = moveAnalysis[idx];
            const m = engine.moveHistory[idx];
            const names = { brilliant:'Brilliant', great:'Great Move', best:'Best Move', excellent:'Excellent', good:'Good', book:'Book', inaccuracy:'Inaccuracy', mistake:'Mistake', miss:'Miss', blunder:'Blunder' };
            const files = 'abcdefgh';

            info.innerHTML = `
                <div class="review-move-info">
                    <div class="review-move-header">
                        <div class="review-move-class">
                            <img src="${CLASSIFICATION_ICONS[a.classification]}" class="review-move-icon">
                            <span class="review-move-notation">${m.notation}</span>
                            <span class="review-move-type">${names[a.classification]}</span>
                        </div>
                        <span class="eval-change ${a.evalChange >= 0 ? 'positive' : 'negative'}">${a.evalChange >= 0 ? '+' : ''}${a.evalChange.toFixed(2)}</span>
                    </div>
                    ${!a.isBestMove && a.bestMove ? `<div class="review-best-move">Best move was <strong>${files[a.bestMove.from.col]}${8-a.bestMove.from.row}${files[a.bestMove.to.col]}${8-a.bestMove.to.row}</strong></div>` : ''}
                </div>
            `;
        }

        function goToStart() { goToMove(-1); }
        function goBack() { goToMove(Math.max(-1, reviewMoveIndex - 1)); }
        function goForward() { goToMove(Math.min(engine.moveHistory.length - 1, reviewMoveIndex + 1)); }
        function goToEnd() { goToMove(engine.moveHistory.length - 1); }

        init();
    </script>
</body>
</html>
